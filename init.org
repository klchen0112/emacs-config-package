#+TITLE: Emacs Configuration
#+AUTHOR: Terje Larsen

* Introduction
terlar's Emacs Configuration. It is not very well documented right now, but hopefully I
will have time to write down some more details later.

The rough details:
- themes :: [[file:lisp/readable-typo-theme.el][readable-typo-theme]] and [[file:lisp/readable-mono-theme.el][readable-mono-theme]]
  - fonts :: [[https://github.com/be5invis/Iosevka][Iosevka Slab]], Noto Sans, Noto Serif
  - semantic highlighting :: [[https://github.com/ankurdave/color-identifiers-mode][color-identifiers-mode]], [[https://github.com/Fanael/rainbow-identifiers][rainbow-identifiers]] (fallback, with wider support)
- menu completion :: [[https://github.com/raxod502/selectrum][selectrum]], [[https://github.com/abo-abo/swiper][ivy]]
- buffer completion :: [[https://github.com/company-mode/company-mode][company-mode]]
- +modal editing (vi) :: [[https://github.com/emacs-evil/evil][evil]]+
- package configuration :: [[https://github.com/jwiegley/use-package][use-package]]
- key definitions :: [[https://github.com/noctuid/general.el][general]]
- code navigation :: [[https://github.com/jacktasia/dumb-jump][dumb-jump]], [[https://github.com/iqbalansari/emacs-source-peek][source-peek]], [[https://github.com/vspinu/imenu-anywhere][imenu-anywhere]]
- syntax checker :: flymake
- persistent undo :: via built-in ~desktop-save-mode~
- language server integration :: [[https://github.com/joaotavora/eglot][eglot]]

** Screenshots
*** org-mode
#+CAPTION: org-mode
[[file:media/tao-yang/org-mode.png]]

*** markdown-mode
#+CAPTION: markdown-mode
[[file:media/tao-yang/markdown-mode.png]]

*** emacs-lisp-mode
#+CAPTION: emacs-lisp-mode
[[file:media/tao-yang/emacs-lisp-mode.png]]

* The beginning
Every good file starts with a nice header and enable lexical scoping as per the
recommendations of the [[https://github.com/bbatsov/emacs-lisp-style-guide#source-code-layout--organization][The Emacs Lisp Style Guide]].
#+begin_src emacs-lisp :tangle yes
;;; init.el --- Emacs Initialization -*- lexical-binding: t; -*-

;; URL: https://github.com/terlar/emacs-config
#+end_src

** Variables
Provide an easy way to toggle debug mode which will set certain variables to produce more
informative output. It can be set either by providing the environment variable =DEBUG= or
start Emacs with =--debug-init=.
#+begin_src emacs-lisp :tangle yes
(eval-and-compile
  (when (getenv "DEBUG") (setq init-file-debug t))
  (setq debug-on-error (and (not noninteractive) init-file-debug)))
#+end_src

Provide a location where Emacs can store data and cache.
#+begin_src emacs-lisp :tangle yes
(eval-and-compile
  (defvar data-dir
    (if (getenv "XDG_DATA_HOME")
        (concat (getenv "XDG_DATA_HOME") "/emacs/")
      (expand-file-name "~/.local/share/emacs/"))
    "Directory for data.")

  (defvar cache-dir
    (if (getenv "XDG_CACHE_HOME")
        (concat (getenv "XDG_CACHE_HOME") "/emacs/")
      (expand-file-name "~/.cache/emacs/"))
    "Directory for cache.")

  (defvar pictures-dir
    (or (getenv "XDG_PICTURES_DIR")
        (expand-file-name "~/Pictures/"))
    "Directory for pictures."))
#+end_src

** UX
Disable bell (both visual and audible)
#+begin_src emacs-lisp :tangle yes
(setq ring-bell-function #'ignore
      visible-bell nil)
#+end_src

Use =y= / =n= instead of =yes= / =no=
#+begin_src emacs-lisp :tangle yes
(setq confirm-kill-emacs #'y-or-n-p)
(fset #'yes-or-no-p #'y-or-n-p)
#+end_src

** Custom file
Put custom defs in a temporary file so it doesn't grow over time.
#+begin_src emacs-lisp :tangle yes
(setq custom-file (expand-file-name "custom.el" temporary-file-directory))
#+end_src

** Load path
#+begin_src emacs-lisp :tangle yes
(eval-and-compile
  (setq load-path
        (append (delete-dups load-path)
                (list (expand-file-name "lisp" user-emacs-directory)
                      (expand-file-name "private" user-emacs-directory)))))
#+end_src

** Shell
Set shell to bash as fish is not compatible with all packages using the shell.
#+begin_src emacs-lisp :tangle yes
(setq shell-file-name "bash")
#+end_src

** Package management
*** use-package
#+begin_src emacs-lisp :tangle yes
(eval-when-compile
  (require 'use-package nil t))
(setq use-package-always-defer t)

(if init-file-debug
    (setq use-package-verbose t
          use-package-expand-minimally nil
          use-package-compute-statistics t)
  (setq use-package-verbose nil
        use-package-expand-minimally t))
#+end_src

** Packages
*** no-littering
Help keeping user Emacs directory clean.
#+begin_src emacs-lisp :tangle yes
(use-package no-littering
  :ensure t
  :demand t
  :custom
  (no-littering-etc-directory data-dir)
  (no-littering-var-directory cache-dir))
#+end_src

*** gcmh
#+begin_src emacs-lisp :tangle yes
(use-package gcmh
  :ensure t
  :hook (after-init . gcmh-mode)
  :custom
  (gcmh-idle-delay 5)
  (gcmh-high-cons-threshold (* 16 1024 1024)) ; 16MB
  (gcmh-verbose init-file-debug))
#+end_src

*** explain-pause-mode
#+begin_src emacs-lisp :tangle yes
(use-package explain-pause-mode
  :ensure t
  :commands (explain-pause-mode)
  :init
  (when init-file-debug
    (explain-pause-mode 1)))
#+end_src

*** exec-path-from-shell
#+begin_src emacs-lisp :tangle yes
(use-package exec-path-from-shell
  :ensure t
  :hook (after-init . exec-path-from-shell-initialize)
  :custom (exec-path-from-shell-check-startup-files nil))
#+end_src

*** server
#+begin_src emacs-lisp :tangle yes
(use-package server
  :commands (server-running-p)
  :preface
  (defun server-ensure-running (frame)
    "Ensure server is running when launching FRAME."
    (with-selected-frame frame
      (unless (server-running-p)
        (server-start))))
  :init
  (add-hook 'after-make-frame-functions #'server-ensure-running))
#+end_src

*** savehist
Persist history.
#+begin_src emacs-lisp :tangle yes
(use-package savehist
  :custom
  (savehist-additional-variables
   '(kill-ring
     search-ring
     regexp-search-ring))
  (savehist-autosave-interval 60)
  (savehist-save-minibuffer-history t)
  :init
  (savehist-mode 1))
#+end_src

** Libraries
*** cl-lib
#+begin_src emacs-lisp :tangle yes
(require 'cl-lib)
#+end_src

*** async
#+begin_src emacs-lisp :tangle yes
(use-package async :ensure t)
#+end_src

*** flymake-quickdef
#+begin_src emacs-lisp :tangle yes
(use-package flymake-quickdef :ensure t :demand t)
#+end_src

** Tangling
Support auto-tangling via =auto-tangle-mode=.
#+begin_src emacs-lisp :tangle yes
(use-package auto-tangle
  :commands (auto-tangle-mode))
#+end_src

* Base
** Performance
No second pass of case-insensitive search over =auto-mode-alist=.
#+begin_src emacs-lisp :tangle yes
(setq auto-mode-case-fold nil)
#+end_src

Give up some bidirectional functionality for slightly faster re-display.
#+begin_src emacs-lisp :tangle yes
(setq bidi-inhibit-bpa t)
(setq-default bidi-display-reordering 'left-to-right
              bidi-paragraph-direction 'left-to-right)
#+end_src

Update UI less frequently
#+begin_src emacs-lisp :tangle yes
(setq idle-update-delay 1.0
      jit-lock-defer-time 0)
#+end_src

Accelerate scrolling with the trade-off of sometimes delayed accurate fontification.
#+begin_src emacs-lisp :tangle yes
(setq fast-but-imprecise-scrolling t)
#+end_src

*** Packages
**** so-long
Improve performance for files with long lines, for example minified code.
#+begin_src emacs-lisp :tangle yes
(use-package so-long
  :defer 2
  :config
  (global-so-long-mode 1))
#+end_src

**** vlf
Large file support. This can view/edit/search and compare large files.
#+begin_src emacs-lisp :tangle yes
(use-package vlf :ensure t)
#+end_src

** Localization
#+begin_src emacs-lisp :tangle yes
(setq-default calendar-week-start-day 1)
#+end_src

** Packages
*** all-the-icons
Support functions for displaying icons. I am trying to use icons where possible.
#+begin_src emacs-lisp :tangle yes
(use-package all-the-icons :ensure t :demand t)
#+end_src

*** auto-minor-mode
Enable minor modes by buffer name and contents. It provides the ~use-package~ keyword
~:minor~ and ~:magic-minor~ where you can specify these rules.
#+begin_src emacs-lisp :tangle yes
(use-package auto-minor-mode :ensure t :demand t)
#+end_src

*** defrepeater
Support defining repeating commands by repeating the last key.
#+begin_src emacs-lisp :tangle yes
(use-package defrepeater
  :ensure t
  :commands (defrepeater))
#+end_src

*** general
More convenient key definitions. I provides the ~use-package~ keyword ~:general~.
#+begin_src emacs-lisp :tangle yes
(use-package general
  :ensure t
  :demand t
  :commands (general-define-key))
#+end_src

*** hide-lines
#+begin_src emacs-lisp :tangle yes
(use-package hide-lines :ensure t)
#+end_src

*** minions
#+begin_src emacs-lisp :tangle yes
(use-package minions
  :ensure t
  :general
  ([C-S-mouse-1] 'minions-minor-modes-menu))
#+end_src

*** quick-peek
Library to display inline popups; used by ~source-peek~.
#+begin_src emacs-lisp :tangle yes
(use-package quick-peek :ensure t)
#+end_src

*** which-key
Display available keybindings in a popup.
#+begin_src emacs-lisp :tangle yes
(use-package which-key
  :ensure t
  :defer 1
  :commands
  (which-key-mode
   which-key-setup-side-window-bottom
   which-key-key-order-alpha)
  :custom
  (which-key-sort-order #'which-key-key-order-alpha)
  (which-key-sort-uppercase-first nil)
  (which-key-add-column-padding 1)
  (which-key-min-display-lines 5)
  (which-key-idle-delay 1)
  :config
  (dolist (item '((("<\\([[:alnum:]-]+\\)>" . nil) . ("\\1" . nil))
                  (("\\`\\?\\?\\'" . nil) . ("λ" . nil))
                  (("<up>" . nil) . ("↑" . nil))
                  (("<right>" . nil) . ("→" . nil))
                  (("<down>" . nil) . ("↓" . nil))
                  (("<left>" . nil) . ("←" . nil))
                  (("SPC" . nil) . ("␣" . nil))
                  (("TAB" . nil) . ("↹" . nil))
                  (("RET" . nil) . ("⏎" . nil))
                  (("DEL" . nil) . ("⌫" . nil))
                  (("deletechar" . nil) . ("⌦" . nil))))
    (cl-pushnew item which-key-replacement-alist :test #'equal))

  (which-key-setup-side-window-bottom)

  (which-key-mode 1))
#+end_src

** Functions
Prevent forms from producing output or other noise.
#+begin_src emacs-lisp :tangle yes
(defmacro quiet! (&rest forms)
  "Run FORMS without making any noise."
  `(if init-file-debug
       (progn ,@forms)
     (let ((message-log-max nil))
       (with-temp-message (or (current-message) "") ,@forms))))

(defun quiet-function-advice (orig-fn &rest args)
  "Advice used to make a function quiet.
Call ORIG-FN with ARGS and suppress the output.

Example:
  (advice-add 'orig-fn :around #'quiet-function-advice)"
  (quiet! (apply orig-fn args)))
#+end_src

*** Display
#+begin_src emacs-lisp :tangle yes
(defun display-ctrl-M-as-newline ()
  "Display `^M' as newline."
  (interactive)
  (setq buffer-display-table (make-display-table))
  (aset buffer-display-table ?\^M [?\n]))
#+end_src

*** Frame
Screenshot current frame in =.svg= or =.png= format.
#+begin_src emacs-lisp :tangle yes
(defun screenshot (type)
  "Save a screenshot of the current frame as an image in TYPE format.
Saves to a temp file and puts the filename in the kill ring."
  (let* ((ext (concat "." (symbol-name type)))
         (filename (make-temp-file "Emacs-" nil ext))
         (data (x-export-frames nil type)))
    (with-temp-file filename
      (insert data))
    (kill-new filename)
    (message filename)))

(defun screenshot-svg ()
  "Save a screenshot of the current frame as an SVG image.
Saves to a temp file and puts the filename in the kill ring."
  (interactive)
  (screenshot 'svg))

(defun screenshot-png ()
  "Save a screenshot of the current frame as an PNG image.
Saves to a temp file and puts the filename in the kill ring."
  (interactive)
  (screenshot 'png))
#+end_src

*** Process
#+begin_src emacs-lisp :tangle yes
(defun send-buffer-to-ssh ()
  "Send the whole buffer to the *ssh* process."
  (interactive)
  (process-send-region "*ssh*" (point-min) (point-max)))

(defun send-to-ssh ()
  "Send selected region or current line to the *ssh* process."
  (interactive)
  (let ((procbuf "*ssh*"))
    (if (use-region-p)
        (process-send-region procbuf (region-beginning) (region-end))
      (process-send-string procbuf (thing-at-point 'line t)))))
#+end_src

*** Window
Dedicated window:
#+begin_src emacs-lisp :tangle yes
(defun toggle-dedicated-window ()
  "Toggle selected window as dedicated window."
  (interactive)
  (set-window-dedicated-p (selected-window)
                          (not (window-dedicated-p (selected-window)))))
#+end_src

Fringe control:
#+begin_src emacs-lisp :tangle yes
(defun no-fringes ()
  "Remove all fringes."
  (interactive)
  (set-window-fringes (selected-window) 0 0 nil))

(defun restore-fringes ()
  "Restore fringes."
  (interactive)
  (set-window-fringes (selected-window) 8 8 t))
#+end_src

** Warnings
#+begin_src emacs-lisp :tangle yes
(use-package warnings
  :custom
  (warning-suppress-types (unless init-file-debug
                            '((comp) (emacs)))))
#+end_src

* Keybindings
I am trying to reduce the amount of keybindings, therefore I present a table of default
keybindings in case I would forget them.

** Aliases
| Keybinding | Alternative |
|------------+-------------|
| =M-=         | =C-[=         |
| =TAB=        | =C-i=         |
| =RET=        | =C-j=         |

** Commands
| Keybinding      | Function                | Description                                                                      |
|-----------------+-------------------------+----------------------------------------------------------------------------------|
| =C-o=             | ~open-line~               | Open line below                                                                  |
| =M-SPC=           | ~just-one-space~          | Ensures just one space                                                           |
| =M-\=             | ~delete-horizontal-space~ | Delete all space                                                                 |
| =M-^=             | ~delete-indentation~      | Join current line with previous line                                             |
| =M-z=             | ~zap-to-char~             | Delete until character                                                           |
| =C-S-backspace=   | ~kill-whole-line~         | Kill entire lines, can be used to move several lines at once                     |
| =M-/=             | ~dabbrev-expand~          | Abbreviation completion                                                          |
| =M-tab= / =C-[ C-i= | ~completion-at-point~     | More context aware completion                                                    |
| =C-w=             | ~kill-region~             | Cut                                                                              |
| =M-w=             | ~kill-ring-save~          | Copy                                                                             |
| =C-y=             | ~yank~                    | Paste                                                                            |
| =M-y=             | ~yank-next~               | Paste (next item)                                                                |
| =C-x SPC=         | ~rectangle-mark-mode~     | Rectangular selection                                                            |
| =C-x r t=         | ~string-rectangle~        | Insert string in beginning of rectangular selection (=C-t= in =rectangle-mark-mode=) |
| =C-M-f=           | ~forward-sexp~            | Move forward inside a balanced expression                                        |
| =C-M-b=           | ~backward-sexp~           | Move backward inside a balanced expression                                       |
| =C-M-n=           | ~forward-list~            | Move forward across one balanced group of parenthesis                            |
| =C-M-p=           | ~backward-list~           | Move backward across one balanced group of parenthesis                           |
| =M-m=             | ~back-to-indentation~     | Move to the first non-whitespace character                                       |
| =M-e=             | ~forward-sentence~        | End of sentence                                                                  |
| =M-a=             | ~backward-sentence~       | Start of sentence                                                                |
| =C-M-d=           | ~down-list~               | Move forward down one level of parenthesis                                       |
| =C-M-u=           | ~backward-up-list~        | Move backward out of one level of parenthesis                                    |
| =C-u C-x $=       | ~set-selective-display~   | Hide/show indentation level                                                      |

** Gnus
| Keybinding | Function                              | Description                                                   |
|------------+---------------------------------------+---------------------------------------------------------------|
| =L=          | ~gnus-group-list-all-groups~            | List all groups (works together with prefix to provide level) |
| =RET=        | ~gnus-topic-select-group~               | List group mails (works together with prefix to see all)      |
| =g=          | ~gnus-group-get-new-news~               | Refresh groups list                                           |
| =G G=        | ~gnus-group-make-nnir-group~            | Search mails at server side                                   |
| =#=          | ~gnus-group-mark-group~                 | Mark                                                          |
| =M-#=        | ~gnus-group-unmark-group~               | Un-mark                                                       |
| =R=          | ~gnus-summary-reply-with-original~      | Reply w/ quoted text                                          |
| =r=          | ~gnus-summary-reply~                    | Reploy w/o quoted text                                        |
| =S W=        | ~gnus-summary-wide-reply-with-original~ | Reply all w/ quoted text                                      |
| =S w=        | ~gnus-summary-wide-reply~               | Reply all w/o quoted text                                     |
| =m= / =C-x m=  | ~gnus-new-mail~                         | Compose new mail                                              |
| =S D e=      | ~gnus-summary-resend-message-edit~      | Re-send a mail in Draft folder                                |
| =C-c C-a=    | ~mml-attach-file~                       | Attach a file                                                 |
| =o=          | ~gnus-mime-save-part~                   | Save attachment                                               |
| =C-c C-f=    | ~gnus-summary-mail-forward~             | Forward mail                                                  |
| =c=          | ~gnus-group-catchup-current~            | Mark mails as read                                            |

** Org
| Keybinding | Function             | Description                                    |
|------------+----------------------+------------------------------------------------|
| =C-c C-w=    | ~org-refile~           | Move headline under another top level headline |
| =<S-right>=  | ~org-shiftright~       | Cycle through todo keywords (right)            |
| =<S-left>=   | ~org-shiftleft~        | Cycle through todo keywords (left)             |
| =C-c C-c=    | ~org-ctrl-c-ctrl-c~    | Set tags for an item                           |
| =C-c C-t=    | ~org-todo~             | Set tags for an item (via menu)                |
| =C-c C-s=    | ~org-schedule~         | Schedule an item                               |
| =C-c C-d=    | ~org-deadline~         | Set a deadline                                 |
| =C-c C-q=    | ~org-set-tags-command~ | Attach tags to item                            |

** Leader keys
#+begin_src emacs-lisp :tangle yes
(defvar leader-key "C-,"
  "The key used for most custom operations.")
(defvar local-leader-key "C-."
  "The key used for major mode operations.")
#+end_src

** Prefixes
#+begin_src emacs-lisp :tangle yes
(defvar launch-prefix "C-c l"
  "Key prefix for commands related to launching.")

(defvar toggle-prefix "C-x t"
  "Key prefix for commands related to toggling.")
(defvar window-prefix "C-'"
  "Key prefix used for commands related to window operations.")

(defvar nav-prefix "M-g"
  "Key prefix used for commands related to navigation.")
(defvar search-prefix "M-s"
  "Key prefix used for commands related to search.")

(defvar next-prefix "M-]"
  "Key prefix used for commands doing a next operation.")
(defvar prev-prefix "M-["
  "Key prefix used for commands doing a previous operation.")
#+end_src

** Global
#+begin_src emacs-lisp :tangle yes
(general-define-key
 :keymaps 'global
 ;; Editing
 "C-z" 'zap-up-to-char
 ;; Files
 "C-c o" 'ff-find-other-file
 "C-c O" 'ff-test-find-other-file
 ;; Window
 "C-`" 'window-toggle-side-windows)
#+end_src

** Navigation
#+begin_src emacs-lisp :tangle yes
(general-define-key
 :keymaps 'global
 :prefix nav-prefix
 "u" 'browse-url)
#+end_src

** Window
#+begin_src emacs-lisp :tangle yes
(general-define-key
 :keymaps 'global
 :prefix window-prefix
 window-prefix 'window-toggle-side-windows
 "d" 'toggle-dedicated-window
 "m" 'maximize-window)
#+end_src

** Next
#+begin_src emacs-lisp :tangle yes
(general-define-key
 :prefix next-prefix
 ""  '(:ignore t :wk "next...")
 "]" '(text-scale-increase      :wk "Text size")
 "b" '(next-buffer              :wk "Buffer")
 "c" '(smerge-next              :wk "Conflict")
 "e" '(next-error               :wk "Error")
 "s" '(flyspell-goto-next-error :wk "Spell error"))

(general-define-key
 [remap text-scale-increase] (defrepeater #'text-scale-increase)
 [remap next-buffer] (defrepeater #'next-buffer)
 [remap smerge-next] (defrepeater #'smerge-next)
 [remap next-error] (defrepeater #'next-error)
 [remap flyspell-goto-next-error] (defrepeater #'flyspell-goto-next-error))
#+end_src

** Previous
#+begin_src emacs-lisp :tangle yes
(general-define-key
 :prefix prev-prefix
 ""  '(:ignore t :wk "previous...")
 "[" '(text-scale-decrease    :wk "Text size")
 "b" '(previous-buffer        :wk "Buffer")
 "c" '(smerge-prev            :wk "Conflict")
 "e" '(previous-error         :wk "Error"))

(general-define-key
 [remap text-scale-decrease] (defrepeater #'text-scale-decrease)
 [remap previous-buffer] (defrepeater #'previous-buffer)
 [remap smerge-prev] (defrepeater #'smerge-prev)
 [remap previous-error] (defrepeater #'previous-error))
#+end_src

** Toggle
#+begin_src emacs-lisp :tangle yes
(general-define-key
 :prefix toggle-prefix
 "c" '(highlight-changes-mode           :wk "Changes")
 "d" '(toggle-debug-on-error            :wk "Debug on error")
 "f" '(hs-minor-mode                    :wk "Code folding")
 "g" '(glasses-mode                     :wk "Readable camelCase")
 "h" '(hl-line-mode                     :wk "Line highlight")
 "l" '(global-display-line-numbers-mode :wk "Line numbers")
 "L" '(so-long-mode                     :wk "Long lines")
 "s" '(subword-mode                     :wk "Sub-word")
 "t" '(toggle-truncate-lines            :wk "Truncate lines")
 "v" '(variable-pitch-mode              :wk "Variable-pitch")
 "w" '(whitespace-mode                  :wk "White-space")
 "x" '(flymake-mode                     :wk "Syntax checker"))
#+end_src

** Launch
#+begin_src emacs-lisp :tangle yes
(general-define-key
 :prefix launch-prefix
 "m" 'gnus
 "p" 'list-processes
 "s" 'screenshot-svg
 "S" 'screenshot-png
 "x" 'regexp-builder
 "w" 'eww)
#+end_src

* Help
#+begin_src emacs-lisp :tangle yes
(general-define-key
 :keymaps 'help-map
 "B" 'find-library
 "u" 'describe-face
 "U" 'list-faces-display
 "'" 'describe-char)
#+end_src

** Packages
*** ghelp
Generic help system.
#+begin_src emacs-lisp :tangle yes
(eval-when-compile
  (require 'find-func))

(use-package ghelp
  :ensure t
  :general
  (:keymaps
   'help-map
   "A" 'ghelp-describe-elisp
   "f" 'ghelp-describe-function
   "k" 'ghelp-describe-key
   "v" 'ghelp-describe-variable)
  (:prefix
   nav-prefix
   "h" 'ghelp-describe-at-point))
#+end_src

*** helpful
Better =*help*= buffer
#+begin_src emacs-lisp :tangle yes
(use-package helpful
  :ensure t
  :general
  (:keymaps
   'help-map
   "C" 'helpful-command
   "M" 'helpful-macro)
  (:keymaps
   'helpful-mode-map
   "[[" 'backward-button
   "]]" 'forward-button))
#+end_src

* Appearance
** Typography
*** Size
#+begin_src emacs-lisp :tangle yes
(defvar init-line-spacing 0.25
  "Spacing between lines.")

(defvar init-default-font-height 120
  "Default font height.")
#+end_src

*** Face
#+begin_src emacs-lisp :tangle yes
(defvar init-fixed-pitch-font "Iosevka Slab"
  "Font used for fixed-pitch faces.")

(defvar init-variable-pitch-font "Noto Sans"
  "Font used for variable-pitch faces.")

(defvar init-serif-font "Noto Serif"
  "Font used for serif faces.")

(defvar init-unicode-font "Noto Sans Mono"
  "Fallback font used for unicode glyphs.")

(defvar init-symbol-fonts '("Noto Emoji" "Symbola")
  "Fonts used for symbol/emoji faces.")
#+end_src

*** Line length
#+begin_src emacs-lisp :tangle yes
(setq-default fill-column 90)
#+end_src

*** Underline
Underline line at descent position, not baseline position.
#+begin_src emacs-lisp :tangle yes
(setq x-underline-at-descent-line t)
#+end_src

** Theme
Use a bar cursor by default.
#+begin_src emacs-lisp :tangle yes
(setq-default cursor-type 'bar)
#+end_src

Setup symbol fonts.
#+begin_src emacs-lisp :tangle yes
(dolist (font init-symbol-fonts)
  (set-fontset-font t 'symbol font nil 'append))
#+end_src

*** Packages
#+begin_src emacs-lisp :tangle yes
(use-package readable-typo-theme
  :demand t
  :custom
  (readable-typo-theme-default-font-height init-default-font-height)
  (readable-typo-theme-line-spacing init-line-spacing)
  (readable-typo-theme-fixed-pitch-font init-fixed-pitch-font)
  (readable-typo-theme-fixed-pitch-serif-font init-fixed-pitch-font)
  (readable-typo-theme-variable-pitch-font init-variable-pitch-font)
  (readable-typo-theme-serif-font init-serif-font)
  :config
  (load-theme 'readable-typo t))

(use-package readable-mono-theme
  :demand t
  :config
  (load-theme 'readable-mono t))
#+end_src

#+begin_src emacs-lisp :tangle yes
(defun toggle-theme-mode ()
  "Toggle dark/light `background-mode' and reload all loaded themes."
  (interactive)
  (customize-set-variable
   'frame-background-mode
   (if (eq 'light (frame-parameter nil 'background-mode)) 'dark 'light))
  (customize-set-variable 'custom-enabled-themes custom-enabled-themes))
#+end_src

*** Echo area
Adjust the font face used for the echo area.
#+begin_src emacs-lisp :tangle yes
(dolist (buffer-name '(" *Echo Area 0*"
                       " *Echo Area 1*"))
  (with-current-buffer (get-buffer-create buffer-name)
    (setq-local face-remapping-alist
                '((default (:height 0.9) variable-pitch)))))
#+end_src

** Layout
*** Frame
See [[info:elisp#Frame%20Layout][Frame Layout]] documentation for details and terminology.
- Add some padding around the whole window (=internal-border-width=) to provide some air.
- Remove GUI elements.
- Maximize the window; A maximized window ensures macOS won't waste extra space all-though
  it is technically not maximized.
- Make the title-bar transparent on macOS.
#+begin_src emacs-lisp :tangle yes
(setq default-frame-alist
      '((undecorated . t)
        (internal-border-width . 16)
        (vertical-scroll-bars . nil)
        (menu-bar-lines . 0)
        (tool-bar-lines . 0)))

(when (eq system-type 'darwin)
  (setq frame-title-format nil)
  (dolist (filter '((ns-transparent-titlebar . t)
                    (ns-appearance . unbound)))
    (cl-pushnew filter default-frame-alist :test #'equal)))
#+end_src

*** Fringe
Setup fringes on both sides and display an indicator for buffer boundaries on the right
side. Display fringes outside margins to have the [[Padding][padding]] on the inside.
#+begin_src emacs-lisp :tangle yes
(setq-default fringes-outside-margins t
              left-fringe-width 8
              right-fringe-width 8
              indicate-buffer-boundaries 'right)
#+end_src

*** Padding
Add margins inside windows to make text feel less crowded. Padding around the frame is
configured via the =internal-border-width= in the [[Frame][Frame]] section.
#+begin_src emacs-lisp :tangle yes
(setq-default left-margin-width 1
              right-margin-width 1)
#+end_src

*** Borders
Add window dividers, mainly to add a border below the mode line.
#+begin_src emacs-lisp :tangle yes
(use-package frame
  :hook
  (server-after-make-frame . window-divider-mode)
  :custom
  (window-divider-default-places t)
  (window-divider-default-bottom-width 1)
  (window-divider-default-right-width 1))
#+end_src

** Mode line
I try to retain functionality from the original mode line as much as possible, but I also
want to simplify it slightly and separate into two parts; left side and right side mode
line. There is a helper function in order to fill up the space needed to make the mode
line appear on the right side. Also the coding system related information will be hidden
if using utf-8-unix.

Define a variable to conveniently access only the major mode part of =mode-line-modes=.
#+begin_src emacs-lisp :tangle yes
(defvar mode-line-major-mode
  `(:propertize ("" mode-name)
                help-echo "Major mode\n\
mouse-1: Display major mode menu\n\
mouse-2: Show help for major mode\n\
mouse-3: Toggle minor modes"
                mouse-face mode-line-highlight
                local-map ,mode-line-major-mode-keymap))
#+end_src

Configure the order and components of the mode line.
#+begin_src emacs-lisp :tangle yes
(setq-default mode-line-format
              '("%e" mode-line-front-space
                mode-line-misc-info
                (vc-mode vc-mode)
                "  "
                mode-line-modified
                mode-line-remote
                mode-line-buffer-identification
                mode-line-position
                (:eval
                 (mode-line-right))
                mode-line-end-spaces))
#+end_src

*** Right alignment
Setup the right aligned mode line and helper functions to display it.
#+begin_src emacs-lisp :tangle yes
(defvar mode-line-right-format nil
  "The mode line to display on the right side.")

(defun mode-line-right ()
  "Render the `mode-line-right-format'."
  (let* ((formatted-line (format-mode-line mode-line-right-format))
         (height (face-attribute 'mode-line :height))
         (scale (if (floatp height) height 1.0)))
    (list
     (propertize
      " " 'display `((space :align-to (- (+ right right-fringe right-margin)
                                         ,(* (string-width formatted-line) scale)))))
     formatted-line)))
#+end_src

Move default components to the right side of the mode line.
#+begin_src emacs-lisp :tangle yes
(setq mode-line-right-format
      (list '(:eval mode-line-mule-info)
            "  "
            mode-line-major-mode))
#+end_src

*** Position
Add position information including column and line number but skip the percentage.
#+begin_src emacs-lisp :tangle yes
(setq mode-line-position-column-line-format '(" L%l:C%C")
      mode-line-percent-position nil)
(column-number-mode 1)
(line-number-mode 1)
#+end_src

*** Coding system
To reduce unnecessary information coding system will not be shown by default if the file
is UTF-8 with UNIX end-of-line.
- Only display "end of line"-mnemonic when not UNIX end-of-line.
- Only display coding system when not UTF-8.
- Other cases displays either with warning/error face in order to draw attention.
#+begin_src emacs-lisp :tangle yes
(setq eol-mnemonic-unix ""
      eol-mnemonic-dos (propertize "[CR+LF]" 'face 'warning)
      eol-mnemonic-mac (propertize "[CR]" 'face 'warning)
      eol-mnemonic-undecided (propertize "[?]" 'face 'error))

(let ((coding (nthcdr 2 mode-line-mule-info)))
  (setcar coding '(:eval (if (string-equal "U" (format-mode-line "%z"))
                             ""
                           (propertize "[%z]" 'face 'warning))))
  coding)
#+end_src

*** Indentation
Display information about the current indentation settings.
#+begin_src emacs-lisp :tangle yes
(use-package indent-info
  :ensure t
  :defer 1
  :commands
  (global-indent-info-mode)
  :custom
  (indent-info-display-change-message-p nil)
  (indent-info-insert-target 'mode-line-mule-info)
  (indent-info-space-format "Spaces: %s")
  (indent-info-tab-format "Tab Size: %s")
  (indent-info-sync-from-editorconfig t)
  (indent-info-sync-to-editorconfig t)
  :config
  (global-indent-info-mode 1))
#+end_src

*** Hide mode line
Support hiding the mode line, this can be useful for different modes displaying documents
or presentation.
#+begin_src emacs-lisp :tangle yes
(use-package hide-mode-line
  :ensure t
  :commands
  (hide-mode-line-mode
   turn-on-hide-mode-line-mode
   turn-off-hide-mode-line-mode))
#+end_src

*** Icons
**** Modified
#+begin_src emacs-lisp :tangle yes
(defun mode-line-modified-icons ()
  "Icon representation of `mode-line-modified'."
  (cond (buffer-read-only
         (concat (all-the-icons-octicon "lock" :v-adjust -0.05) " "))
        ((buffer-modified-p)
         (concat (all-the-icons-faicon "floppy-o" :v-adjust -0.05) " "))
        ((and buffer-file-name
              (not (file-exists-p buffer-file-name)))
         (concat (all-the-icons-octicon "circle-slash" :v-adjust -0.05) " "))))

(with-eval-after-load 'all-the-icons
  (setq-default mode-line-modified '((:eval (mode-line-modified-icons)))))
#+end_src

**** Remote
#+begin_src emacs-lisp :tangle yes
(defun mode-line-remote-icons ()
  "Icon representation of `mode-line-remote'."
  (when (and buffer-file-name
             (file-remote-p buffer-file-name))
    (concat (all-the-icons-octicon "radio-tower" :v-adjust -0.02) " ")))

(with-eval-after-load 'all-the-icons
  (setq-default mode-line-remote   '((:eval (mode-line-remote-icons)))))
#+end_src

**** VCS
Shorten long Git branch names as well as replace Git prefix with a nice icon.
#+begin_src emacs-lisp :tangle yes
(defun +shorten-vc-mode-line (string)
  "Shorten `version-control' STRING in mode-line and add icon."
  (cond
   ((string-prefix-p "Git" string)
    (concat (all-the-icons-octicon "git-branch" :v-adjust -0.05)
            " "
            (if (> (length string) 30)
                (concat (substring-no-properties string 4 30) "…")
              (substring-no-properties string 4))))
   (t
    string)))
(advice-add 'vc-git-mode-line-string :filter-return #'+shorten-vc-mode-line)
#+end_src

* Display
** Window
*** Favor horizontal splits
#+begin_src emacs-lisp :tangle yes
(setq split-width-threshold nil)
#+end_src

*** Manage layouts
Undo/redo between window layouts.
#+begin_src emacs-lisp :tangle yes
(use-package winner
  :hook
  (window-setup . winner-mode)
  :custom
  (winner-dont-bind-my-keys t)
  :general
  (:prefix
   next-prefix
   next-prefix '(winner-redo :wk "Window History"))
  (:prefix
   prev-prefix
   prev-prefix '(winner-undo :wk "Window History"))
  ([remap winner-redo] (defrepeater #'winner-redo)
   [remap winner-undo] (defrepeater #'winner-undo)))
#+end_src

Transpose window arrangement.
#+begin_src emacs-lisp :tangle yes
(use-package transpose-frame
  :ensure t
  :general
  (:prefix
   window-prefix
   "t" 'transpose-frame
   "f" 'flip-frame
   "F" 'flop-frame))
#+end_src

*** Zoom
Zoom a window to display as a single window temporarily.
#+begin_src emacs-lisp :tangle yes
(use-package zoom-window
  :ensure t
  :general
  (:prefix
   window-prefix
   "z" 'zoom-window-zoom))
#+end_src

** Buffer
*** Popups
Always display pop up buffers at the bottom and regard all star buffers as such buffers.
#+begin_src emacs-lisp :tangle yes
(setq switch-to-buffer-obey-display-actions t)
(dolist (rule `((,(rx bos "*" (one-or-more anything) "*" (optional "<" (one-or-more anything) ">") eos)
                 (display-buffer-reuse-window
                  display-buffer-in-side-window)
                 (reusable-frames . visible)
                 (side . bottom)
                 (window-height . 0.4))
                ("^*Warn about privacy*" display-buffer-pop-up-window)))
  (cl-pushnew rule display-buffer-alist :test #'equal))
#+end_src

*** Hide async shell command buffers
#+begin_src emacs-lisp :tangle yes
(cl-pushnew '("^*Async Shell Command*" . (display-buffer-no-window))
            display-buffer-alist
            :test #'equal)
#+end_src

*** Visual Fill Column
Wrap lines according to =fill-column= in =visual-line-mode=.
#+begin_src emacs-lisp :tangle yes
(use-package visual-fill-column
  :ensure t
  :custom
  (visual-fill-column-center-text t))
#+end_src

* Editing
** Indentation
Convert between tabs and spaces (only tabify initial white-space).
#+begin_src emacs-lisp :tangle yes
(setq-default tabify-regexp "^\t* [ \t]+")
#+end_src

** Text flow
Wrap at words and don't require double spaces to end a sentence.
#+begin_src emacs-lisp :tangle yes
(setq-default word-wrap t)
#+end_src

** Kill-ring
Save clipboard contents into kill-ring before replacing them.
#+begin_src emacs-lisp :tangle yes
(setq save-interprogram-paste-before-kill t)
#+end_src

** Packages
*** avy
Jump to things.
#+begin_src emacs-lisp :tangle yes
(use-package avy
  :ensure t
  :custom
  (avy-all-windows nil)
  :general
  (:prefix
   search-prefix
   "SPC" 'avy-goto-word-or-subword-1
   "s" 'avy-goto-char
   "l" 'avy-goto-line
   "m" 'avy-pop-mark))
#+end_src

*** cycle-quotes
#+begin_src emacs-lisp :tangle yes
(use-package cycle-quotes
  :ensure t
  :general
  ("C-x C-'" 'cycle-quotes)
  ([remap cycle-quotes] (defrepeater #'cycle-quotes)))
#+end_src

*** goto-addr
Buttonize URLs and e-mail addresses in the current buffer.
#+begin_src emacs-lisp :tangle yes
(use-package goto-addr
  :hook
  (text-mode . goto-address-mode)
  (prog-mode . goto-address-prog-mode))
#+end_src

*** grugru
Cycle through words, symbols and patterns.
#+begin_src emacs-lisp :tangle yes
(use-package grugru
  :ensure t
  :commands (grugru-default-setup)
  :general
  (:prefix
   next-prefix
   "r" '(grugru-forward :wk "Rotate text"))
  (:prefix
   prev-prefix
   "r" '(grugru-backward :wk "Rotate text"))
  ([remap grugru-backward] (defrepeater #'grugru-backward)
   [remap grugru-forward] (defrepeater #'grugru-forward))
  :config
  (grugru-default-setup)
  (grugru-define-global 'symbol '("assert" "refute"))
  (grugru-define-on-major-mode 'nix-mode 'symbol '("true" "false")))
#+end_src

*** string-inflection-cycle
#+begin_src emacs-lisp :tangle yes
(use-package string-inflection
  :ensure t
  :general
  ("M-_" 'string-inflection-all-cycle))
#+end_src

*** smartparens
Auto-insert matching parenthesis and highlight matching parenthesis.
#+begin_src emacs-lisp :tangle yes
(use-package smartparens
  :ensure t
  :hook
  (eval-expression-minibuffer-setup . smartparens-strict-mode)
  :commands
  (smartparens-global-strict-mode
   show-smartparens-global-mode)
  :general
  (:prefix
   toggle-prefix
   "p" 'smartparens-strict-mode)
  (:keymaps
   'smartparens-mode-map
   "M-'" 'sp-change-inner
   "M-C" 'sp-clone-sexp
   "M-D" 'sp-unwrap-sexp
   "M-R" 'sp-rewrap-sexp
   "M-W" 'sp-wrap-round)
  (:keymaps
   'smartparens-strict-mode-map
   [remap kill-region] 'nil)
  :preface
  (defun +smartparens-no-autoinsert-pair-advice (orig-fn &rest args)
    "Disable command smartparens autoinsert when running ORIG-FN with ARGS."
    (let ((sp-autoinsert-pair nil))
      (apply orig-fn args)))
  :init
  (smartparens-global-strict-mode 1)
  (show-smartparens-global-mode 1)
  :config
  (require 'smartparens-config)

  (sp-local-pair 'minibuffer-inactive-mode "'" nil :actions nil)

  (sp-with-modes 'org-mode
    (sp-local-pair "*" "*"
                   :actions '(insert wrap)
                   :unless '(sp-point-after-word-p sp-point-at-bol-p)
                   :wrap "C-*" :skip-match 'sp--org-skip-asterisk)
    (sp-local-pair "_" "_" :unless '(sp-point-after-word-p)
                   :wrap "C-_")
    (sp-local-pair "/" "/" :unless '(sp-point-after-word-p)
                   :post-handlers '(("[d1]" "SPC")))
    (sp-local-pair "~" "~" :unless '(sp-point-after-word-p)
                   :post-handlers '(("[d1]" "SPC")))
    (sp-local-pair "=" "=" :unless '(sp-point-after-word-p)
                   :post-handlers '(("[d1]" "SPC")))
    (sp-local-pair "«" "»"))

  (sp-with-modes 'nix-mode
    (sp-local-pair "\"" "\"")
    (sp-local-pair "''" "''"
                   :unless '(sp-in-comment-p
                             sp-in-string-quotes-p)))

  (advice-add 'hippie-expand :around #'+smartparens-no-autoinsert-pair-advice))
#+end_src

*** visual-regexp
Visually highlight regular expression searches as you type. Also supports replace.
#+begin_src emacs-lisp :tangle yes
(use-package visual-regexp
  :ensure t
  :general
  ("M-s r" 'vr/query-replace
   "M-s R" 'vr/replace))
#+end_src

*** whitespace
Display whitespace
#+begin_src emacs-lisp :tangle yes
(use-package whitespace
  :custom
  (whitespace-line-column fill-column)
  (whitespace-style
   '(face tabs tab-mark spaces space-mark trailing lines-tail))
  (whitespace-display-mappings
   '((tab-mark 9 [8250 9])
     (newline-mark 10 [172 10])
     (space-mark 32 [183] [46]))))
#+end_src

*** whole-line-or-region
Cut/copy (=C-w= / =M-w=) the current line if no region is active.
#+begin_src emacs-lisp :tangle yes
(use-package whole-line-or-region
  :ensure t
  :hook
  (after-init . whole-line-or-region-global-mode))
#+end_src

*** yasnippet
#+begin_src emacs-lisp :tangle yes
(use-package yasnippet
  :ensure t
  :defer 1
  :commands
  (yas--templates-for-key-at-point)
  :custom
  (yas-also-auto-indent-first-line t)
  (yas-snippet-dirs (list (expand-file-name "snippets" user-emacs-directory)))
  ;; Nested snippets
  (yas-triggers-in-field t)
  (yas-wrap-around-region t)
  :general
  (:keymaps
   'yas-minor-mode-map
   [tab] 'nil
   "TAB" 'nil
   "M-o" 'yas-insert-snippet)
  :init
  (setq yas-verbosity 0)
  :config
  (yas-global-mode 1))

(use-package yasnippet-snippets
  :ensure t
  :hook
  (yas-minor-mode . yasnippet-snippets-initialize))
#+end_src

*** yatemplate
#+begin_src emacs-lisp :tangle yes
(use-package autoinsert
  :hook
  (after-init . auto-insert-mode)
  :custom
  (auto-insert-query nil))

(use-package yatemplate
  :ensure t
  :hook
  (auto-insert-mode . yatemplate-fill-alist))
#+end_src

** Appearance
*** Page breaks
Display page breaks as a horizontal line.
#+begin_src emacs-lisp :tangle yes
(use-package page-break-lines
  :ensure t
  :defer 1
  :config
  (global-page-break-lines-mode 1))
#+end_src

*** Line highlight
Disabled by default. When enabled, only highlight in the selected window.
#+begin_src emacs-lisp :tangle yes
(use-package hl-line
  :custom
  (hl-line-sticky-flag nil)
  (global-hl-line-sticky-flag nil))
#+end_src

* Buffers
Prevent generation of useless lock and backup files.
#+begin_src emacs-lisp :tangle yes
(setq create-lockfiles nil
      make-backup-files nil)
#+end_src

Don't require confirmation when opening a new buffer.
#+begin_src emacs-lisp :tangle yes
(setq confirm-nonexistent-file-or-buffer t)
#+end_src

Remove visual indicators from non-selected windows
#+begin_src emacs-lisp :tangle yes
(setq highlight-nonselected-windows nil)
(setq-default cursor-in-non-selected-windows nil)
#+end_src

** Auto save
#+begin_src emacs-lisp :tangle yes
(use-package files
  :hook
  (after-init . auto-save-visited-mode)
  :custom
  (auto-save-no-message t)
  (save-abbrevs 'silently))
#+end_src

** Auto executable scripts
#+begin_src emacs-lisp :tangle yes
(add-hook 'after-save-hook #'executable-make-buffer-file-executable-if-script-p)
#+end_src

** Minibuffer
Enable recursive minibuffers and keep the point out of the minibuffer.
#+begin_src emacs-lisp :tangle yes
(setq enable-recursive-minibuffers t
      minibuffer-prompt-properties
      '(read-only t point-entered minibuffer-avoid-prompt face minibuffer-prompt))
#+end_src

Give some more room to the minbuffer.
#+begin_src emacs-lisp :tangle yes
(setq max-mini-window-height 0.3
      resize-mini-windows 'grow-only)
#+end_src

*** No fringes
Don't show fringes in the minibuffer.
#+begin_src emacs-lisp :tangle yes
(defun disable-minibuffer-window-fringes (&optional frame)
  "Disable the window fringes for minibuffer window in FRAME."
  (let ((target (if frame frame (selected-frame))))
    (with-selected-frame target
      (set-window-fringes (minibuffer-window) 0 0 nil))))
(add-hook 'after-make-frame-functions #'disable-minibuffer-window-fringes)
(add-hook 'minibuffer-setup-hook #'disable-minibuffer-window-fringes)
#+end_src

*** History
Track minibuffer history
#+begin_src emacs-lisp :tangle yes
(setq history-delete-duplicates t
      history-length 500)
#+end_src

*** Miniedit
Edit minibuffer in a new temporary buffer by pressing =C-c '=.
#+begin_src emacs-lisp :tangle yes
(use-package miniedit
  :ensure t
  :general
  (:keymaps
   '(minibuffer-local-map
     minibuffer-local-ns-map
     minibuffer-local-completion-map
     minibuffer-local-must-match-map)
   "C-c '" 'miniedit))
#+end_src

** Scrolling
More procedural scrolling.
#+begin_src emacs-lisp :tangle yes
(setq auto-window-vscroll nil
      hscroll-margin 5
      hscroll-step 5
      scroll-margin 0
      scroll-preserve-screen-position t)

(setq-default scroll-down-aggressively 0.01
              scroll-up-aggressively 0.01)
#+end_src

** Packages
*** autorevert
Revert buffers when underlying files change.
#+begin_src emacs-lisp :tangle yes
(use-package autorevert
  :custom
  (auto-revert-verbose nil))
#+end_src

*** default-text-scale
#+begin_src emacs-lisp :tangle yes
(use-package default-text-scale
  :ensure t
  :general
  ("C-M-=" 'default-text-scale-increase)
  ("C-M--" 'default-text-scale-decrease)
  ("C-M-0" 'default-text-scale-reset))
#+end_src

*** eldoc
#+begin_src emacs-lisp :tangle yes
(use-package eldoc
  :config
  (global-eldoc-mode 1))
#+end_src

*** rainbow-mode
Display colors inline.
#+begin_src emacs-lisp :tangle yes
(use-package rainbow-mode
  :ensure t
  :minor
  "-theme\\.el\\'"
  :hook
  help-mode)
#+end_src

*** readable
#+begin_src emacs-lisp :tangle yes
(use-package readable
  :hook
  ((eww-mode
    Info-mode
    markdown-mode
    nov-mode
    org-mode
    outline-mode
    rst-mode) . readable-mode))
#+end_src

*** relative-buffers
#+begin_src emacs-lisp :tangle yes
(use-package relative-buffers
  :ensure t
  :hook
  (after-init . global-relative-buffers-mode)
  :custom
  (relative-buffers-project-prefix t))
#+end_src

*** wgrep-ag
Writeable grep buffer with ability to apply the changes to all the files.
#+begin_src emacs-lisp :tangle yes
(use-package wgrep-ag
  :ensure t
  :custom
  (wgrep-auto-save-buffer t))
#+end_src

* Navigation
Allow repeated mark popping. This behavior is similar to Vim's =C-o=. With this
configuration you can press =C-u= and continuously =C-SPC= to jump to previous entries in the
mark ring.
#+begin_src emacs-lisp :tangle yes
(setq set-mark-command-repeat-pop t)
#+end_src

** Dired
#+begin_src emacs-lisp :tangle yes
(use-package dired
  :hook
  (dired-mode . auto-revert-mode)
  (dired-mode . hl-line-mode)
  (dired-mode . dired-hide-details-mode)
  :custom
  (dired-listing-switches "-al --group-directories-first")
  ;; Always copy/delete recursively
  (dired-recursive-copies  'always)
  (dired-recursive-deletes 'top))
#+end_src

*** Editable
#+begin_src emacs-lisp :tangle yes
(use-package wdired
  :general
  (:keymaps
   'dired-mode-map
   "C-c '" 'wdired-change-to-wdired-mode))
#+end_src

*** Search
#+begin_src emacs-lisp :tangle yes
(use-package find-dired
  :custom
  (find-ls-option '("-print0 | xargs -0 ls -ld" . "-ld"))
  :general
  ("C-x D" 'find-dired))
#+end_src

*** Sidebar
#+begin_src emacs-lisp :tangle yes
(use-package dired-sidebar
  :ensure t
  :hook
  (dired-sidebar-mode . hide-mode-line-mode)
  (dired-sidebar-mode . hl-line-mode)
  (dired-sidebar-mode . variable-pitch-mode)
  (dired-sidebar-mode . init-dired-sidebar)
  :general
  (:prefix
   leader-key
   "n" 'dired-sidebar-toggle-sidebar)
  :preface
  (defun init-dired-sidebar ()
    (setq cursor-type nil)
    (stripe-buffer-mode 0)))
#+end_src

*** Subtree
Display subtrees in dired view.
#+begin_src emacs-lisp :tangle yes
(use-package dired-subtree
  :ensure t
  :custom
  (dired-subtree-use-backgrounds nil)
  (dired-subtree-line-prefix "     "))
#+end_src

*** Stripes
Striped dired buffers.
#+begin_src emacs-lisp :tangle yes
(use-package stripe-buffer
  :ensure t
  :hook
  (dired-mode . stripe-buffer-mode))
#+end_src

*** Icons
#+begin_src emacs-lisp :tangle yes
(use-package all-the-icons-dired
  :ensure t
  :hook
  (dired-mode . all-the-icons-dired-mode))
#+end_src

*** Git
#+begin_src emacs-lisp :tangle yes
(use-package dired-git-info
  :ensure t
  :general
  (:keymaps
   'dired-mode-map
   ")" 'dired-git-info-mode))
#+end_src

** Occur
#+begin_src emacs-lisp :tangle yes
(use-package replace
  :general
  (:prefix
   search-prefix
   "o" 'occur)
  (:keymaps
   'occur-mode-map
   "C-c '" 'occur-edit-mode))
#+end_src

*** Packages
**** noccur
#+begin_src emacs-lisp :tangle yes
(use-package noccur
  :ensure t
  :general
  (:prefix
   search-prefix
   "O" 'noccur-project))
#+end_src

** Packages
*** bibliothek
Management tool for a library of PDFs.
#+begin_src emacs-lisp :tangle yes
(use-package bibliothek
  :ensure t
  :custom
  (bibliothek-path '("~/books" "~/documents/research/papers"))
  (bibliothek-recursive t)
  :general
  (:prefix
   launch-prefix
   "b" 'bibliothek))
#+end_src

*** bookmark
Keep track of bookmarks
#+begin_src emacs-lisp :tangle yes
(use-package bookmark
  :custom
  (bookmark-save-flag 1))
#+end_src

*** ctrlf
#+begin_src emacs-lisp :tangle yes
(use-package ctrlf
  :ensure t
  :defer 2
  :config
  (ctrlf-mode 1))
#+end_src

*** ctrlxo
#+begin_src emacs-lisp :tangle yes
(use-package ctrlxo
  :ensure t
  :general
  ("C-x o" 'ctrlxo))
#+end_src

*** deadgrep
#+begin_src emacs-lisp :tangle yes
(use-package deadgrep
  :ensure t
  :general
  (:prefix search-prefix "g" 'deadgrep)
  (:keymaps 'deadgrep-mode-map "C-c '" 'deadgrep-edit-mode))
#+end_src

*** find-file
#+begin_src emacs-lisp :tangle yes
(use-package find-file
  :init
  (setq-default ff-quiet-mode t)
  (put 'ff-search-directories 'safe-local-variable (lambda (x) (seq-every-p #'stringp x))))

(use-package ff-test :demand t)
#+end_src

*** find-file-rg
Find files via =rg --files=.
#+begin_src emacs-lisp :tangle yes
(use-package find-file-rg
  :ensure t
  :general
  ("C-c f" 'find-file-rg))
#+end_src

*** goto-last-change
Move point through buffer-undo-list positions.
#+begin_src emacs-lisp :tangle yes
(use-package goto-chg
  :ensure t
  :general
  (:prefix
   next-prefix
   "l" '(goto-last-change :wk "Change"))
  (:prefix
   prev-prefix
   "l" '(goto-last-change-reverse :wk "Change")))
#+end_src

*** link-hint
Hint mode for links.
#+begin_src emacs-lisp :tangle yes
(use-package link-hint
  :ensure t
  :general
  (:prefix nav-prefix
   "l" 'link-hint-open-link
   "L" 'link-hint-copy-link))
#+end_src

*** recentf
Keep track of recently opened files.
#+begin_src emacs-lisp :tangle yes
(use-package recentf
  :defer 2
  :custom
  (recentf-exclude
   (list "/tmp/"                        ; Temp-files
         "/dev/shm"                     ; Potential secrets
         "/ssh:"                        ; Files over SSH
         "/nix/store"                   ; Files in Nix store
         "/TAGS$"                       ; Tag files
         "^/\\.git/.+$"                 ; Git contents
         "\\.?ido\\.last$"
         "\\.revive$"
         "^/var/folders/.+$"
         (concat "^" cache-dir ".+$")
         (concat "^" data-dir ".+$")))
  (recentf-filename-handlers '(abbreviate-file-name))
  (recentf-max-menu-items 0)
  (recentf-max-saved-items 300)
  (recentf-auto-cleanup 'never)
  :preface
  (defun completing-read-file-candidate (candidate)
    "Format `completing-read' file CANDIDATE with `abbreviate-file-name'
and icon prefix from `all-the-icons-icon-for-file'."
    (propertize candidate
                'selectrum-candidate-display-prefix
                (concat
                 (cond
                  ((file-directory-p candidate) (all-the-icons-icon-for-dir candidate))
                  (t (all-the-icons-icon-for-file candidate)))
                 "\t")))

  (defun recentf-open-files+ ()
    "Use `completing-read' to open a recent file."
    (interactive)
    (let ((files (cl-mapcar #'completing-read-file-candidate recentf-list)))
      (find-file (completing-read "Find recent file: " files nil t))))
  :config
  (quiet! (recentf-mode 1)))
#+end_src

*** saveplace
Keep track of last point place to resume editing in the same file.
#+begin_src emacs-lisp :tangle yes
(use-package saveplace
  :defer 2
  :config
  (save-place-mode 1))
#+end_src

** Project
Project interactions. Prefix project buffer files with the project name and relative path.
#+begin_src emacs-lisp :tangle yes
(use-package projectile
  :ensure t
  :defer 2
  :custom
  (projectile-completion-system 'default)
  (projectile-enable-caching nil)
  (projectile-file-exists-remote-cache-expire nil)
  (projectile-globally-ignored-file-suffixes
   '(".elc" ".pyc" ".o" ".hi" ".class" ".cache"))
  (projectile-globally-ignored-files
   '("TAGS" "GPATH" "GRTAGS" "GTAGS"))
  (projectile-ignored-projects (list data-dir))
  (projectile-indexing-method 'alien)
  :general
  (:keymaps
   'projectile-mode-map
   [remap eshell] (general-predicate-dispatch #'eshell
                    :docstring "Creat an interactive Eshell buffer (project aware)"
                    (projectile-project-p) #'projectile-run-eshell)
   [remap term] (general-predicate-dispatch #'term
                  :docstring "Create an interactive terminal buffer (project aware)"
                  (projectile-project-p) #'projectile-run-term))
  (:keymaps
   'projectile-mode-map
   :prefix
   leader-key
   "p" '(:keymap projectile-command-map :package projectile :wk "project"))
  :preface
  (defun +projectile-cache-current-file (orig-fun &rest args)
    "Don't cache ignored files."
    (unless (cl-some (lambda (path)
                       (string-prefix-p buffer-file-name
                                        (expand-file-name path)))
                     (projectile-ignored-directories))
      (apply orig-fun args)))
  :init
  (advice-add 'projectile-cache-current-file :around #'+projectile-cache-current-file)
  :config
  (setq projectile-globally-ignored-directories
        (append '("_build"
                  "target" "project/target"
                  "vendor/bundle" "vendor/cache"
                  "elm-stuff" "tests/elm-stuff")
                projectile-globally-ignored-directories))
  (setq projectile-other-file-alist
        (append '(("less" "css")
                  ("styl" "css")
                  ("sass" "css")
                  ("scss" "css")
                  ("css" "scss" "sass" "less" "styl")
                  ("jade" "html")
                  ("pug" "html")
                  ("html" "jade" "pug" "jsx" "tsx"))
                projectile-other-file-alist))
  (setq projectile-project-root-files
        (append '("package.json" "Package.swift" "README.md")
                projectile-project-root-files))

  (projectile-mode 1))
#+end_src

Manage project repositories.
#+begin_src emacs-lisp :tangle yes
(use-package ivy-ghq
  :ensure t
  :defer 2
  :custom
  (ivy-ghq-short-list t)
  :general
  ("C-c p" 'ivy-ghq-open))
#+end_src

* Completion
No completion with tab.
#+begin_src emacs-lisp :tangle yes
(setq tab-always-indent t)
#+end_src

** Company
#+begin_src emacs-lisp :tangle yes
(use-package company
  :ensure t
  :custom
  (company-show-numbers t)
  (company-backends
   '((company-files
      company-keywords
      company-capf
      company-dabbrev-code
      company-dabbrev)))
  :hook
  (prog-mode . company-mode)
  :general
  (:keymaps
   'company-mode-map
   "C-?" 'company-complete)
  (:keymaps
   'company-active-map
   ;; No interference with return key
   [return]  'nil
   "RET"     'nil
   "C-e" 'company-complete-selection
   "C-f" 'company-complete-selection
   "C-n" 'company-select-next
   "C-p" 'company-select-previous))
#+end_src

** Hippie
Smart expansion completions, excellent for completing lines.
Replace abbrev completion (=M-/=) with hippie expand.

Complete in the following order:
- Try to expand word "dynamically", searching the current buffer.
- Try to expand word "dynamically", searching all other buffers.
- Try to expand word "dynamically", searching the kill ring.
- Try to complete text as a file name, as many characters as unique.
- Try to complete text as a file name.
- Try to expand word before point according to all abbrev tables.
- Try to complete the current line to an entire line in the buffer.
- Try to complete as an Emacs Lisp symbol, as many characters as unique.
- Try to complete word as an Emacs Lisp symbol.
#+begin_src emacs-lisp :tangle yes
(use-package hippie-exp
  :commands
  (hippie-expand)
  :custom
  (hippie-expand-try-functions-list
   '(try-expand-dabbrev-visible
     try-expand-dabbrev
     try-complete-file-name-partially
     try-complete-file-name
     try-expand-all-abbrevs
     try-expand-list
     try-expand-line
     try-expand-line-all-buffers
     try-complete-lisp-symbol-partially
     try-complete-lisp-symbol))
  :general
  ([remap dabbrev-expand] 'hippie-expand))
#+end_src

** Selectrum
Incremental selection narrowing interface for completions.
#+begin_src emacs-lisp :tangle yes
(use-package selectrum
  :ensure t
  :hook
  (after-init . selectrum-mode)
  (selectrum-mode . selectrum-define-keys)
  :custom
  (selectrum-extend-current-candidate-highlight t)
  (selectrum-show-indices t)
  :general
  ("C-c SPC" 'selectrum-repeat)
  (:keymaps
   'selectrum-minibuffer-map
   "C-e" 'selectrum-move-end-of-line-or-insert-current-candidate)
  :preface
  (defun selectrum-define-keys ()
    (dotimes (i (min selectrum-num-candidates-displayed 10))
      (general-define-key
       :keymaps 'selectrum-minibuffer-map
       (format "M-%d" (mod (1+ i) 10))
       `(lambda () (interactive)
          (selectrum-select-current-candidate ,(1+ i))))))

  (defun selectrum-move-end-of-line-or-insert-current-candidate (arg)
    "Move to end of line or insert current candidate.
   ARG lines can be used."
    (interactive "p")
    (if (eolp) (selectrum-insert-current-candidate) (move-end-of-line arg))))

(use-package orderless
  :ensure t
  :custom
  (selectrum-refine-candidates-function #'orderless-filter)
  (selectrum-highlight-candidates-function #'orderless-highlight-matches))
#+end_src

** Ivy
#+begin_src emacs-lisp :tangle yes
(use-package ivy
  :ensure t
  :custom
  (ivy-hooks-alist '((t . hl-line-mode)))
  (ivy-wrap t)
  (ivy-on-del-error-function #'ignore)
  (ivy-use-virtual-buffers t)
  ;; Allow selecting the prompt as a candidate (e.g for creating a new file)
  (ivy-use-selectable-prompt t)
  (ivy-fixed-height-minibuffer t)
  ;; Don't use ^ as initial input.
  (ivy-initial-inputs-alist nil)
  :general
  (:keymaps
   'ivy-mode-map
   :prefix
   window-prefix
   "v" 'ivy-push-view
   "V" 'ivy-pop-view
   "'" 'ivy-switch-view)
  (:keymaps
   'ivy-occur-grep-mode-map
   "C-c '" 'ivy-wgrep-change-to-wgrep-mode)
  (:keymaps
   'ivy-minibuffer-map
   "C-<return>" 'ivy-immediate-done
   "C-e"        '+ivy-move-end-of-line-or-done
   "C-f"        '+ivy-forward-or-done
   "C-l"        'ivy-alt-done
   "C-u"        'ivy-kill-line
   "C-w"        'ivy-backward-kill-word)
  :preface
  (defun +ivy-move-end-of-line-or-done (arg)
    "Move to end of current line or consider ivy operation done.
   ARG lines can be used."
    (interactive "p")
    (if (eolp) (ivy-alt-done) (move-end-of-line arg)))
  (defun +ivy-forward-or-done (n)
    "Move point forward or consider ivy operation done.
      N characters can be used."
    (interactive "p")
    (if (eolp) (ivy-alt-done) (forward-char n))))
#+end_src

*** Packages
**** counsel-tramp
Navigate tramp files.
#+begin_src emacs-lisp :tangle yes
(use-package counsel-tramp
  :ensure t
  :general
  (:prefix
   leader-key
   "t" 'counsel-tramp))
#+end_src

**** ivy-yasnippet
Snippets with preview.
#+begin_src emacs-lisp :tangle yes
(use-package ivy-yasnippet
  :ensure t
  :general
  ([remap yas-insert-snippet] 'ivy-yasnippet)
  (:keymaps
   'yas-minor-mode-map
   :prefix
   leader-key
   "y" 'ivy-yasnippet))
#+end_src

* Development
Reduce scroll margin.
#+begin_src emacs-lisp :tangle yes
(defun +prog-scroll-margin-setup ()
  "Setup `scroll-margin' for `prog-mode'."
  (setq-local scroll-margin 3))
(add-hook 'prog-mode-hook #'+prog-scroll-margin-setup)
#+end_src

** Compilation
Kill compilation process before stating another and save all buffers on ~compile~.
#+begin_src emacs-lisp :tangle yes
(use-package compile
  :custom
  (compilation-always-kill t)
  (compilation-ask-about-save nil)
  (compilation-scroll-output t)
  :general
  (:keymaps
   'global
   :prefix
   local-leader-key
   "c" 'recompile
   "C" 'compile)
  :init
  (put 'compile-command 'safe-local-variable 'stringp))

(make-variable-buffer-local 'compile-command)
#+end_src

*** ANSI escape
#+begin_src emacs-lisp :tangle yes
(require 'ansi-color)
(defun +colorize-compilation ()
  "Colorize from `compilation-filter-start' to `point'."
  (let ((inhibit-read-only t))
    (ansi-color-apply-on-region compilation-filter-start (point))))
(add-hook 'compilation-filter-hook #'+colorize-compilation)
#+end_src

** Containers
*** Docker
#+begin_src emacs-lisp :tangle yes
(use-package docker
  :ensure t
  :general
  (:prefix
   leader-key
   "d" 'docker
   "c" 'docker-compose))
#+end_src

**** Files
Support for Docker related files.
#+begin_src emacs-lisp :tangle yes
(use-package dockerfile-mode :ensure t)
(use-package docker-compose-mode :ensure t)
#+end_src

**** Tramp
#+begin_src emacs-lisp :tangle yes
(use-package docker-tramp
  :ensure t
  :custom
  (docker-tramp-use-names t))
#+end_src

*** Kubernetes
#+begin_src emacs-lisp :tangle yes
(use-package kubernetes :ensure t)
#+end_src

**** Tramp
#+begin_src emacs-lisp :tangle yes
(use-package kubernetes-tramp :ensure t)
#+end_src

** Coverage
#+begin_src emacs-lisp :tangle yes
(use-package coverlay
  :ensure t
  :hook
  (coverlay-minor-mode . init-coverlay)
  :custom
  (coverlay:mark-tested-lines nil)
  :general
  (:prefix
   local-leader-key
   "v" 'coverlay-mode-toggle)
  :init
  (defun init-coverlay ()
    "Setup `coverlay-mode'."
    (setq-local
     coverlay:base-path
     (expand-file-name (locate-dominating-file (file-name-directory (buffer-file-name))
                                               "coverage"))))
  (defun coverlay-mode-toggle ()
    "Turn on `coverlay-mode'."
    (interactive)
    (if (bound-and-true-p coverlay-minor-mode)
        (coverlay-minor-mode 0)
      (coverlay-minor-mode 1)
      (when (and (buffer-file-name) (not (bound-and-true-p coverlay--loaded-filepath)))
        (let ((coverage-file (expand-file-name "coverage/lcov.info" coverlay:base-path)))
          (when (file-exists-p coverage-file)
            (coverlay-watch-file coverage-file)))))))
#+end_src

** Docs
*** DevDocs
Lookup documentation via DevDocs.
#+begin_src emacs-lisp :tangle yes
(use-package devdocs
  :ensure t
  :general
  (:prefix nav-prefix "K" 'devdocs-search))
#+end_src

** Editing
*** separedit
#+begin_src emacs-lisp :tangle yes
(use-package separedit
  :ensure t
  :custom
  (separedit-preserve-string-indentation t)
  :general
  (:keymaps
   '(prog-mode-map typescript-mode-map)
   "C-c '" 'separedit))
#+end_src

** Eval
*** quickrun
#+begin_src emacs-lisp :tangle yes
(use-package quickrun
  :ensure t
  :hook
  (quickrun--mode . display-ctrl-M-as-newline)
  :general
  (:prefix
   local-leader-key
   "q" 'quickrun
   "Q" 'quickrun-autorun-mode))
#+end_src

** Folding
Code folding.
#+begin_src emacs-lisp :tangle yes
(use-package hideshow
  :hook (prog-mode . hs-minor-mode)
  :custom
  (hs-hide-comments-when-hiding-all nil)
  :general
  (:prefix
   (concat leader-key " " "z")
   ""      '(:ignore t :wk "hide")
   "c"     'hs-hide-block
   "o"     'hs-show-block
   "C"     'hs-hide-all
   "O"     'hs-show-all
   "l"     'hs-hide-level
   "z"     'hs-toggle-hiding
   "<tab>" 'hs-toggle-hiding)
  :preface
  (defun +hs-fold-overlay-ellipsis (ov)
    (when (eq 'code (overlay-get ov 'hs))
      (overlay-put
       ov 'display (propertize " … " 'face 'font-lock-comment-face))))
  :init
  (setq hs-allow-nesting t
        hs-set-up-overlay #'+hs-fold-overlay-ellipsis))
#+end_src

** Formatting
*** apheleia
Reformat buffer without moving point.
#+begin_src emacs-lisp :tangle yes
(use-package apheleia
  :ensure t
  :init
  (put 'apheleia-formatter 'safe-local-variable 'symbolp)
  :config
  (progn ;; JavaScript/TypeScript
    (cl-pushnew '(eslint . (npx "eslint_d" "--fix-to-stdout" "--stdin" "--stdin-filename" file)) apheleia-formatters :test #'equal))
  (progn ;; Nix
    (cl-pushnew '(nixfmt . ("nixfmt")) apheleia-formatters :test #'equal))
  (progn ;; Ruby
    (cl-pushnew '(rufo . ("rufo" "--simple-exit")) apheleia-formatters :test #'equal)
    (cl-pushnew '(ruby-mode . rufo) apheleia-mode-alist :test #'equal)))
#+end_src

*** reformatter
Custom formatters. Use in a specific project via =.dir-locals.el=, this can be achieved via
the mode mechanism:
#+begin_src text
((some-major-mode
   (mode . FORMATTER-on-save)))
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package reformatter
  :ensure t
  :demand t
  :config
  (defgroup reformatter nil "Simple formatters defined by reformatter."
    :group 'reformatter)
  (reformatter-define black :program "black" :args '("-"))
  (reformatter-define nixfmt :program "nixfmt"))
#+end_src

** Jump to definition
Jump to definition is really useful and I prefer doing so without TAGS which is pretty
much the default for most modes. I am using the excellent package ~dumb-jump~ to jump via
grep tools e.g. (=grep=, =rx=, =ag=)

Don't ask about keeping current list of tags tables.
#+begin_src emacs-lisp :tangle yes
(use-package etags
  :custom
  (tags-add-tables nil))
#+end_src

*** xref
#+begin_src emacs-lisp :tangle yes
(use-package xref
  :general
  (:prefix
   nav-prefix
   "i" 'xref-find-definitions
   "o" 'xref-find-definitions-other-window))
#+end_src

*** dumb-jump
#+begin_src emacs-lisp :tangle yes
(use-package dumb-jump
  :ensure t
  :custom
  (dumb-jump-default-project user-emacs-directory))
#+end_src

** Refactor
Refactoring commands for various languages.
#+begin_src emacs-lisp :tangle yes
(use-package emr
  :ensure t
  :general
  (:keymaps
   'prog-mode-map
   "M-<return>" 'emr-show-refactor-menu))
#+end_src

** REPL
*** comint
#+begin_src emacs-lisp :tangle yes
(use-package comint
  :custom
  (comint-use-prompt-regexp t)
  :preface
  (defun comint-process-tab-complete ()
    "Complete by sending the current input and TAB character to the process."
    (interactive)
    (let* ((buffer (current-buffer))
           (pmark (process-mark (get-buffer-process buffer))))
      (when (> (point) (marker-position pmark))
        (kill-region pmark (point))
        (comint-send-string buffer (concat (pop kill-ring) "\t")))))
  :general
  (:keymaps
   'comint-mode-map
   "<tab>" 'comint-process-tab-complete
   "C-c C-k" 'term-char-mode))
#+end_src

*** repl-toggle
#+begin_src emacs-lisp :tangle yes
(use-package repl-toggle
  :ensure t
  :custom
  (rtog/goto-buffer-fun 'pop-to-buffer)
  (rtog/mode-repl-alist '((emacs-lisp-mode . ielm)
                          (clojure-mode . clojure-repl)
                          (elm-mode . elm-repl-load)
                          (go-mode . gorepl-run)
                          (js-mode . js-repl)
                          (lisp-mode . slime)
                          (lua-mode . lua-repl)
                          (nix-mode . nix-repl)
                          (racket-mode . racket-repl)
                          (typescript-mode . run-ts)))
  :general
  (:keymaps
   'prog-mode-map
   :prefix local-leader-key
   "r" 'rtog/toggle-repl)
  :preface
  (defun clojure-repl ()
    "Open a Clojure REPL."
    (interactive)
    (pop-to-buffer (cider-current-repl nil 'ensure)))

  (defun js-repl ()
    "Open a JavaScript REPL."
    (interactive)
    (if (indium-client-process-live-p) (indium-switch-to-repl-buffer) (nodejs-repl)))

  (defun lua-repl ()
    "Open a Lua REPL."
    (interactive)
    (pop-to-buffer (process-buffer (lua-get-create-process)))))
#+end_src

*** Persistent history in comint
#+begin_src emacs-lisp :tangle yes
(defun +comint-history-write-on-exit (process event)
  "Write `comint' history on exit.
Receives PROCESS and EVENT."
  (comint-write-input-ring)
  (let ((buf (process-buffer process)))
    (when (buffer-live-p buf)
      (with-current-buffer buf
        (insert (format "\nProcess %s %s" process event))))))

(defun +comint-history-enable ()
  "Enable `comint' history."
  (let ((process (get-buffer-process (current-buffer))))
    (when process
      (setq comint-input-ring-file-name
            (expand-file-name
             (format "comint-%s-history" (process-name process))
             cache-dir))
      (comint-read-input-ring)
      (set-process-sentinel process #'+comint-history-write-on-exit))))
#+end_src

** Syntax checker
Silence next/previous error, by default it produces a message every time.
#+begin_src emacs-lisp :tangle yes
(advice-add 'next-error :around #'quiet-function-advice)
(advice-add 'previous-error :around #'quiet-function-advice)
#+end_src

*** flymake
Connect flymake to =next-error-function= and add some navigation bindings. Disable the
legacy diagnostic functions as some of them have bugs and cause instability (mainly the
Haskell one).
#+begin_src emacs-lisp :tangle yes
(use-package flymake
  :hook
  (flymake-mode . flymake-setup-next-error-function)
  :custom
  (help-at-pt-timer-delay 0.1)
  (help-at-pt-display-when-idle '(flymake-diagnostic))
  (flymake-proc-ignored-file-name-regexps '("\\.l?hs\\'"))
  :general
  (:keymaps
   'flymake-mode-map
   :prefix
   local-leader-key
   "!" 'flymake-show-diagnostics-buffer)
  (:keymaps
   'flymake-mode-map
   :prefix next-prefix
   "E" 'flymake-goto-next-error)
  (:keymaps
   'flymake-mode-map
   :prefix prev-prefix
   "E" 'flymake-goto-prev-error)
  (:keymaps
   'flymake-diagnostics-buffer-mode-map
   "n" 'flymake-diagnostics-next-error
   "p" 'flymake-diagnostics-prev-error
   "j" 'flymake-diagnostics-next-error
   "k" 'flymake-diagnostics-prev-error
   "RET" 'flymake-goto-diagnostic
   "TAB" 'flymake-show-diagnostic)
  :preface
  (defun flymake-setup-next-error-function ()
    (setq next-error-function 'flymake-next-error-compat))

  (defun flymake-next-error-compat (&optional n _)
    (flymake-goto-next-error n))

  (defun flymake-diagnostics-next-error ()
    (interactive)
    (forward-line)
    (when (eobp) (forward-line -1))
    (flymake-show-diagnostic (point)))

  (defun flymake-diagnostics-prev-error ()
    (interactive)
    (forward-line -1)
    (flymake-show-diagnostic (point)))
  :init
  (remove-hook 'flymake-diagnostic-functions 'flymake-proc-legacy-flymake))
#+end_src

**** Diagnostics at point
#+begin_src emacs-lisp :tangle yes
(use-package flymake-diagnostic-at-point
  :ensure t
  :hook
  (flymake-mode . flymake-diagnostic-at-point-mode)
  :preface
  (defun flymake-diagnostic-at-point-quick-peek (text)
    "Display the flymake diagnostic TEXT with `quick-peek'`."
    (quick-peek-show (concat flymake-diagnostic-at-point-error-prefix text)))
  :custom
  (flymake-diagnostic-at-point-error-prefix nil))
#+end_src

** Version control
#+begin_src emacs-lisp :tangle yes
(setq diff-font-lock-prettify t
      vc-follow-symlinks t
      vc-make-backup-files nil)
#+end_src

*** browse-at-remote
Open link to files in the web UI connected to a repository.
#+begin_src emacs-lisp :tangle yes
(use-package browse-at-remote
  :ensure t
  :general
  ("C-x v SPC" 'browse-at-remote))
#+end_src

*** diff
#+begin_src emacs-lisp :tangle yes
(use-package diff
  :general
  (:keymaps
   'diff-mode-map
   :prefix next-prefix
   "d" '(diff-hunk-next :wk "Diff Hunk"))
  (:keymaps
   'diff-mode-map
   :prefix prev-prefix
   "d" '(diff-hunk-prev :wk "Diff Hunk"))
  ([remap diff-hunk-next] (defrepeater #'diff-hunk-next)
   [remap diff-hunk-prev] (defrepeater #'diff-hunk-prev)))
#+end_src

*** ediff
- Split horizontally
- Use existing frame instead of creating a new one
- Add a third resolution option, copy both A and B to C
#+begin_src emacs-lisp :tangle yes
(use-package ediff
  :hook
  (ediff-quit . winner-undo)
  (ediff-keymap-setup . init-ediff-keys)
  :custom
  (ediff-diff-options "-w")
  (ediff-merge-split-window-function #'split-window-horizontally)
  (ediff-split-window-function #'split-window-horizontally)
  (ediff-window-setup-function #'ediff-setup-windows-plain)
  :preface
  (defun ediff-copy-both-to-C ()
    "Copy change from both A and B to C."
    (interactive)
    (ediff-copy-diff
     ediff-current-difference nil 'C nil
     (concat
      (ediff-get-region-contents ediff-current-difference 'A ediff-control-buffer)
      (ediff-get-region-contents ediff-current-difference 'B ediff-control-buffer))))

  (defun init-ediff-keys ()
    "Setup keybindings for `ediff-mode'."
    (general-define-key
     :keymaps 'ediff-mode-map
     "d" '(ediff-copy-both-to-C      :wk "Copy both to C")
     "j" '(ediff-next-difference     :wk "Next difference")
     "k" '(ediff-previous-difference :wk "Previous difference"))))
#+end_src

*** diff-hl
Diff indicators in fringe
#+begin_src emacs-lisp :tangle yes
(use-package diff-hl
  :ensure t
  :defer 2
  :custom
  (diff-hl-ask-before-revert-hunk nil)
  :hook
  (dired-mode         . diff-hl-dired-mode)
  (magit-post-refresh . diff-hl-magit-post-refresh)
  :general
  (:keymaps
   'diff-hl-mode-map
   :prefix next-prefix
   "d" '(diff-hl-next-hunk :wk "Diff Hunk"))
  (:keymaps
   'diff-hl-mode-map
   :prefix prev-prefix
   "d" '(diff-hl-previous-hunk :wk "Diff Hunk"))
  ([remap diff-hl-next-hunk] (defrepeater #'diff-hl-next-hunk)
   [remap diff-hl-previous-hunk] (defrepeater #'diff-hl-previous-hunk))
  :preface
  (autoload 'diff-hl-flydiff-mode "diff-hl-flydiff" nil t)
  (autoload 'diff-hl-dired-mode "diff-hl-dired" nil t)
  :config
  (global-diff-hl-mode 1)
  (diff-hl-flydiff-mode 1))
#+end_src

*** magit
Enhanced git related views and commands.
#+begin_src emacs-lisp :tangle yes
(use-package magit
  :ensure t
  :defer 2
  :hook
  (git-commit-mode . +git-commit-set-fill-column)
  :custom
  (magit-log-buffer-file-locked t)
  (magit-refs-show-commit-count 'all)
  (magit-save-repository-buffers 'dontask)
  (vc-msg-git-show-commit-function 'magit-show-commit)
  :general
  (:keymaps
   'dired-mode-map
   "C-x g" 'magit)
  :preface
  (defun +git-commit-set-fill-column ()
    "Set `fill-column' for git commit."
    (setq fill-column 72))

  (defvar magit-process-create-pull-request-regexp
    "remote: Create pull request for.*\nremote: +\\(?1:[^ ]+\\)[^\n]*"
    "Regular expression detecting PR.")

  (defun magit-process-ask-create-pull-request (_process string)
    "Detect pull request STRING and ask to create PR."
    (when (string-match magit-process-create-pull-request-regexp string)
      (let ((url (match-string 1 string))
            (inhibit-message t))
        (if (y-or-n-p "Create PR? ")
            (browse-url (url-encode-url url))))))
  :config
  (setq magit-process-prompt-functions #'magit-process-ask-create-pull-request)
  ;; Unset pager as it is not supported properly inside emacs.
  (setenv "GIT_PAGER" ""))
#+end_src

*** vc-msg
Popup commit message for current line
#+begin_src emacs-lisp :tangle yes
(use-package vc-msg
  :ensure t
  :general
  ("C-x v p" 'vc-msg-show))
#+end_src

** Packages
*** envrc
Project-specific environment variables via =direnv=.
#+begin_src emacs-lisp :tangle yes
(use-package envrc
  :ensure t
  :if (executable-find "direnv")
  :defer 1
  :general
  (:keymaps
   'envrc-mode-map
   "C-c e" 'envrc-command-map)
  :config
  (envrc-global-mode 1))
#+end_src

*** editorconfig
Use [[https://editorconfig.org/][EditorConfig]] to maintain the coding styles used across different projects.
#+begin_src emacs-lisp :tangle yes
(use-package editorconfig
  :ensure t
  :defer 1
  :custom
  (editorconfig-trim-whitespaces-mode 'ws-butler-mode)
  :config
  (dolist (mode '(emacs-lisp-mode lisp-mode))
    (setq editorconfig-indentation-alist
          (assq-delete-all mode editorconfig-indentation-alist)))
  (editorconfig-mode 1))
#+end_src

*** eglot
Generic Language Server Protocol integration via ~eglot~.
#+begin_src emacs-lisp :tangle yes
(use-package eglot
  :ensure t
  :defer 3
  :hook
  ((haskell-mode
    java-mode
    ruby-mode
    rustic-mode
    typescript-mode) . eglot-ensure)
  (js-mode . +eglot-ensure-unless-json-mode)
  :preface
  (defun +eglot-ensure-unless-json-mode ()
    (unless (derived-mode-p 'json-mode) (eglot-ensure)))
  :custom
  (eglot-autoshutdown t)
  (eglot-confirm-server-initiated-edits nil)
  (eglot-sync-connect nil)
  :general
  (:keymaps
   'eglot-mode-map
   :prefix nav-prefix
   "k" 'eglot-help-at-point)
  (:keymaps
   'eglot-mode-map
   :prefix local-leader-key
   "e" '(:ignore t :wk "eglot")
   "ea" 'eglot-code-actions
   "ef" 'eglot-format
   "eh" 'eglot-help-at-point
   "er" 'eglot-rename)
  :config
  (cl-pushnew '((js-mode typescript-mode) . ("typescript-language-server" "--stdio"))
              eglot-server-programs
              :test #'equal))
#+end_src

*** helm-make
Execute make tasks.
#+begin_src emacs-lisp :tangle yes
(use-package helm-make
  :ensure t
  :custom
  (helm-make-completion-method 'ivy)
  :general
  (:prefix
   leader-key
   "m" (general-predicate-dispatch #'helm-make
         :docstring "Run make task (project aware)"
         (projectile-project-p) #'helm-make-projectile)))
#+end_src

*** hl-todo
Highlight *TODO* inside comments and strings.
#+begin_src emacs-lisp :tangle yes
(use-package hl-todo
  :ensure t
  :hook
  (prog-mode . hl-todo-mode)
  :general
  (:prefix next-prefix "t" '(hl-todo-next :wk "Todo"))
  (:prefix prev-prefix "t" '(hl-todo-previous :wk "Todo"))
  ([remap hl-todo-next] (defrepeater #'hl-todo-next)
   [remap hl-todo-previous] (defrepeater #'hl-todo-previous)))
#+end_src

*** idle-highlight
Highlight symbol at point on idle.
#+begin_src emacs-lisp :tangle yes
(use-package idle-highlight-mode
  :ensure t
  :hook prog-mode)
#+end_src

*** imenu-anywhere
Jump to document locations in current buffer
#+begin_src emacs-lisp :tangle yes
(use-package imenu-anywhere
  :ensure t
  :general
  (:prefix
   search-prefix
   "i" 'imenu
   "I" 'imenu-anywhere))
#+end_src

*** imenu-extra
Easily add document locations via regular expressions.
#+begin_src emacs-lisp :tangle yes
(use-package imenu-extra
  :ensure t
  :functions (imenu-extra-auto-setup))
#+end_src

*** imenu-list
Document locations in a sidebar.
#+begin_src emacs-lisp :tangle yes
(use-package imenu-list
  :ensure t
  :general
  (:prefix
   leader-key
   "i" 'imenu-list-smart-toggle))
#+end_src

*** source-peek
Peek definition (Display the function source inline).
#+begin_src emacs-lisp :tangle yes
(use-package source-peek
  :ensure t
  :general
  (:prefix
   nav-prefix
   "SPC" 'source-peek))
#+end_src

*** ws-butler
Delete trailing white-space before save, but *only* for edited lines.
#+begin_src emacs-lisp :tangle yes
(use-package ws-butler
  :ensure t
  :custom
  (ws-butler-convert-leading-tabs-or-spaces t)
  :commands
  (ws-butler-mode))
#+end_src

** Appearance
*** Highlight delimiters
Visually separate delimiter pairs.
#+begin_src emacs-lisp :tangle yes
(use-package rainbow-delimiters
  :ensure t
  :custom
  (rainbow-delimiters-max-face-count 3)
  :hook
  ((clojure-mode
    emacs-lisp-mode
    ielm-mode
    lisp-mode
    racket-mode) . rainbow-delimiters-mode))
#+end_src

*** Highlight identifiers
Highlight source code identifiers based on their name.
#+begin_src emacs-lisp :tangle yes
(use-package color-identifiers-mode :ensure t)

(use-package rainbow-identifiers
  :ensure t
  :custom
  (rainbow-identifiers-choose-face-function 'rainbow-identifiers-cie-l*a*b*-choose-face))
#+end_src

*** Ligatures
#+begin_src emacs-lisp :tangle yes
(use-package ligature
  :ensure t
  :hook (prog-mode . ligature-mode)
  :config
  (ligature-set-ligatures
   'prog-mode
   '("-<<" "-<" "-<-" "<--" "<---" "<<-" "<-" "->" "->>" "-->" "--->" "->-" ">-" ">>-" "<->" "<-->" "<--->" "<---->" "<!--"
     "=<<" "=<" "=<=" "<==" "<===" "<<=" "<=" "=>" "=>>" "==>" "===>" "=>=" ">=" ">>=" "<=>" "<==>" "<===>" "<====>" "<!---"
     "<------" "------>" "<=====>" "<~~" "<~" "~>" "~~>" "::" ":::" "\\/" "/\\" "==" "!=" "/=" "~=" "<>" "===" "!==" "=/=" "=!="
     ":=" ":-" ":+" "<*" "<*>" "*>" "<|" "<|>" "|>" "<." "<.>" ".>" "+:" "-:" "=:" "<******>" "(*" "*)" "++" "+++" "|-" "-|"
     "&&" "||")))

(use-package prog-mode
  :custom
  (prettify-symbols-unprettify-at-point t))
#+end_src

* Major modes
** emacs-lisp
#+begin_src emacs-lisp :tangle yes
(add-hook 'emacs-lisp-mode-hook #'flymake-mode)
(add-hook 'emacs-lisp-mode-hook #'outline-minor-mode)

(general-define-key
 :keymaps 'emacs-lisp-mode-map
 :prefix local-leader-key
 "c" 'emacs-lisp-byte-compile
 "C" 'emacs-lisp-byte-compile-and-load
 "l" `(,(lambda () (interactive) (load-file (buffer-file-name))) :wk "Load file")
 "t" 'ert)

(custom-set-variables
 '(ad-redefinition-action 'accept)
 '(apropos-do-all t)
 '(enable-local-eval 'maybe)
 '(enable-local-variables :safe))
#+end_src

Specific safe local code can be specified via:
- ~safe-local-variable-values~
- ~safe-local-eval-forms~
- ~safe-local-eval-function~

*** Syntax checking
#+begin_src emacs-lisp :tangle yes
(defun elisp-flymake--load-use-package-before-compile ()
  "Ensure `use-package' macro is available for code snippets."
  (eval-when-compile
    (require 'use-package nil t)))
(advice-add 'elisp-flymake--batch-compile-for-flymake :before #'elisp-flymake--load-use-package-before-compile)
#+end_src

*** ielm
Persist ielm history.
#+begin_src emacs-lisp :tangle yes
(defvar +ielm-comint-input-ring nil)
(with-eval-after-load 'savehist
  (cl-pushnew '+ielm-comint-input-ring savehist-additional-variables :test #'equal))

(defun +ielm-set-comint-input-ring ()
  "Restore `ielm' history."
  (setq-local comint-input-ring-size 200)
  (add-hook 'kill-buffer-hook #'+ielm-save-comint-input-ring nil t)
  (when +ielm-comint-input-ring
    (setq comint-input-ring +ielm-comint-input-ring)))

(defun +ielm-save-comint-input-ring ()
  "Save `ielm' history."
  (setq +ielm-comint-input-ring comint-input-ring))

(add-hook 'ielm-mode-hook #'+ielm-set-comint-input-ring)
#+end_src

*** eval-expression
Highlight parenthesis.
#+begin_src emacs-lisp :tangle yes
(add-hook 'eval-expression-minibuffer-setup-hook #'show-paren-mode)
#+end_src

*** Packages
**** auto-compile
Auto-compile Elisp files.
#+begin_src emacs-lisp :tangle yes
(use-package auto-compile
  :ensure t
  :hook
  (emacs-lisp-mode . auto-compile-on-load-mode)
  (emacs-lisp-mode . auto-compile-on-save-mode)
  :custom
  (auto-compile-display-buffer nil)
  (auto-compile-use-mode-line nil))
#+end_src

**** eros
Evaluation results in overlay.
#+begin_src emacs-lisp :tangle yes
(use-package eros
  :ensure t
  :hook
  (emacs-lisp-mode . eros-mode))
#+end_src

**** highlight-quoted
#+begin_src emacs-lisp :tangle yes
(use-package highlight-quoted
  :ensure t
  :hook
  (emacs-lisp-mode . highlight-quoted-mode))
#+end_src

**** package-lint-flymake
#+begin_src emacs-lisp :tangle yes
(use-package package-lint-flymake
  :ensure t
  :hook
  (emacs-lisp-mode . package-lint-flymake-setup-when-package)
  :commands (package-lint-flymake-setup)
  :preface
  (defun package-lint-flymake-setup-when-package ()
    "Enable `package-lint-flymake' when buffer seems to be a package."
    (autoload 'package-lint--provided-feature "package-lint")
    (when (package-lint--provided-feature)
      (package-lint-flymake-setup))))
#+end_src

**** suggest
Discover functions.
#+begin_src emacs-lisp :tangle yes
(use-package suggest
  :ensure t
  :commands
  (suggest)
  :general
  (:keymaps
   'emacs-lisp-mode-map
   :prefix local-leader-key
   "s" '+suggest-popup)
  :preface
  (defun +suggest-popup ()
    "Open suggest as a popup."
    (interactive)
    (let* ((window         (selected-window))
           (dedicated-flag (window-dedicated-p window)))
      (set-window-dedicated-p window t)
      (suggest)
      (set-window-dedicated-p window dedicated-flag))))
#+end_src

*** Appearance
**** Regular expression escapes
Improve readability of escape characters in regular expressions.
#+begin_src emacs-lisp :tangle yes
(use-package easy-escape
  :ensure t
  :hook
  (emacs-lisp-mode . easy-escape-minor-mode))
#+end_src

** erc
#+begin_src emacs-lisp :tangle yes
(use-package erc
  :hook
  (erc-mode . init-erc-parens)
  :custom
  (erc-hide-list '("JOIN" "PART" "QUIT"))
  (erc-prompt-for-password nil)
  :preface
  (defun init-erc-parens ()
    "Parenthesis configuration for `erc-mode'."
    (smartparens-strict-mode 0)
    (smartparens-mode 1)))
#+end_src

** org
#+begin_src emacs-lisp :tangle yes
(use-package org
  :ensure t
  :hook
  (org-mode . auto-fill-mode)
  :minor
  ("init\\.org\\'" . auto-tangle-mode)
  :custom
  (org-agenda-files '("~/org/Personal.org" "~/org/Work.org"))
  (org-confirm-babel-evaluate nil)
  (org-babel-load-languages
   '((emacs-lisp . t)
     (clojure    . t)
     (js         . t)
     (plantuml   . t)
     (shell      . t)))
  (org-edit-src-content-indentation 0)
  (org-log-done 'time)
  (org-modules nil)
  (org-plantuml-exec-mode 'plantuml)
  (org-special-ctrl-a/e t)
  (org-src-preserve-indentation nil)
  (org-src-tab-acts-natively t)
  (org-src-window-setup 'current-window)
  (org-tag-alist
   '(("@work"  . ?w)
     ("@home"  . ?h)
     ("laptop" . ?l)))
  :general
  ("C-C a" 'org-agenda)
  (:keymaps
   'org-mode-map
   "C-'" 'nil
   "C-," 'nil)
  :functions
  (org-babel-load-languages)
  :preface
  (autoload 'org-get-outline-path "org-refile" nil t)
  :config
  (org-babel-do-load-languages 'org-babel-load-languages org-babel-load-languages))
#+end_src

*** Packages
**** org-babel-eval-in-repl
Evaluation of source code blocks in REPL.
#+begin_src emacs-lisp :tangle yes
(use-package org-babel-eval-in-repl
  :ensure t
  :general
  (:keymaps
   'org-mode-map
   "C-<return>" '+org-ctrl-return
   "M-<return>" '+org-meta-return)
  :preface
  (defun +org-ctrl-return ()
    "Run `ober-eval-in-repl' if in source code block and `org-insert-heading-respect-content' otherwise."
    (interactive)
    (if (org-in-block-p '("src" "example"))
        (ober-eval-in-repl)
      (call-interactively #'org-insert-heading-respect-content)))
  (defun +org-meta-return ()
    "Run `ober-eval-block-in-repl' if in source code block or example block and `org-meta-return' otherwise."
    (interactive)
    (if (org-in-block-p '("src" "example"))
        (ober-eval-block-in-repl)
      (call-interactively #'org-meta-return))))
#+end_src

**** org-cliplink
Paste links from clipboard and automatically fetch title.
#+begin_src emacs-lisp :tangle yes
(use-package org-cliplink
  :ensure t
  :general
  (:keymaps
   'org-mode-map
   :prefix local-leader-key
   "l" 'org-cliplink))
#+end_src

**** org-noter
Annotate documents with ~org-mode~.
#+begin_src emacs-lisp :tangle yes
(use-package org-noter :ensure t)
#+end_src

**** org-preview-html
Preview org-file in an ~eww~ buffer.
#+begin_src emacs-lisp :tangle yes
(use-package org-preview-html :ensure t)
#+end_src

**** org-radiobutton
Support for radiobuttons.
#+begin_src emacs-lisp :tangle yes
(use-package org-radiobutton
  :ensure t
  :hook
  (org-mode . org-radiobutton-mode))
#+end_src

**** org-tree-slide
Presentation mode.
#+begin_src emacs-lisp :tangle yes
(use-package org-tree-slide
  :ensure t
  :hook
  (org-tree-slide-play . turn-on-hide-mode-line-mode)
  (org-tree-slide-stop . turn-off-hide-mode-line-mode)
  (org-tree-slide-play . no-fringes)
  (org-tree-slide-stop . restore-fringes)
  :custom
  (org-tree-slide-header nil)
  (org-tree-slide-slide-in-effect nil)
  :general
  (:keymaps
   'org-tree-slide-mode-map
   "<right>" 'org-tree-slide-move-next-tree
   "<left>" 'org-tree-slide-move-previous-tree)
  (:keymaps
   'org-mode-map
   :prefix local-leader-key
   "p" 'org-tree-slide-mode))
#+end_src

**** ob-http
#+begin_src emacs-lisp :tangle yes
(use-package ob-http
  :ensure t
  :init
  (cl-pushnew '(http . t) org-babel-load-languages :test #'equal))
#+end_src

*** Appearance
This sections makes ~org-mode~ look more beautiful and appealing.

#+begin_src emacs-lisp :tangle yes
(use-package org
  :hook
  (org-babel-after-execute . org-redisplay-inline-images)
  (org-mode . init-org-prettify-syntax)
  :custom
  (org-fontify-quote-and-verse-blocks t)
  (org-hide-emphasis-markers t)
  (org-pretty-entities t)
  (org-src-fontify-natively t)
  (org-startup-indented t)
  (org-startup-with-inline-images t)
  :preface
  (defun init-org-prettify-syntax ()
    "Prettify syntax with symbols."
    (dolist (symbol '(("#+title:" . "⋮")
                      ("#+TITLE:" . "⋮")
                      ("#+subtitle:" . "⋮")
                      ("#+SUBTITLE:" . "⋮")
                      ("#+begin_src" . "λ")
                      ("#+BEGIN_SRC" . "λ")
                      ("#+end_src" . "≋")
                      ("#+end_src" . "≋")
                      ("#+begin_quote" . "“")
                      ("#+BEGIN_QUOTE" . "“")
                      ("#+end_quote" . "”")
                      ("#+END_QUOTE" . "”")))
      (cl-pushnew symbol prettify-symbols-alist :test #'equal))
    (dolist (n (number-sequence 1 8 1))
      (let ((symbol (cons (concat (make-string n ?*) " ") (-interpose '(Br . Bl) (make-list (+ 1 n) ?\s)))))
        (cl-pushnew symbol prettify-symbols-alist :test #'equal)))
    (prettify-symbols-mode 1)))
#+end_src

**** Emphasis
Allow more newlines (1 to 4) for emphasized text, useful when filling long text.
#+begin_src emacs-lisp :tangle yes
(use-package org
  :config
  (setcar (nthcdr 4 org-emphasis-regexp-components) 4)
  (org-set-emph-re 'org-emphasis-regexp-components org-emphasis-regexp-components))
#+end_src

**** Variable pitch
Use variable-pitch font but still make sure everything aligns.
#+begin_src emacs-lisp :tangle yes
(use-package org-variable-pitch
  :ensure t
  :hook (org-mode . org-variable-pitch-minor-mode)
  :custom
  (org-variable-pitch-fontify-headline-prefix t))
#+end_src

**** Headings
#+begin_src emacs-lisp :tangle yes
(use-package org
  :custom
  (org-ellipsis "  ")
  (org-fontify-whole-heading-line t)
  (org-fontify-todo-headline t)
  (org-fontify-done-headline t))
#+end_src

**** Bullet lists
#+begin_src emacs-lisp :tangle yes
(font-lock-add-keywords
 'org-mode
 '(("^ +\\([-*+]\\) "
    (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "⏺"))))
   ("^ *[-*+] \\[\\(X\\)\\] "
    (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "✕"))))))
#+end_src

**** Task lists
Use symbols to represent task state.
#+begin_src emacs-lisp :tangle yes
(defun init-org-prettify-task-symbols ()
  "Prettify task list symbols."
  (dolist (symbol '(("TODO"      . "⚑")
                    ("DOING"     . "⚐")
                    ("NEXT"      . "⚐")
                    ("WAITING"   . "⏳")
                    ("SOMEDAY"   . "⛅")
                    ("PROJECT"   . "📁")
                    ("DONE"      . "✔")
                    ("CANCELED"  . "✘")
                    ("CANCELLED" . "✘")))
    (cl-pushnew symbol prettify-symbols-alist :test #'equal)))
(add-hook 'org-mode-hook #'init-org-prettify-task-symbols)
#+end_src

**** Breadcrumbs
Remove style from heading breadcrumbs.
#+begin_src emacs-lisp :tangle yes
(defun +org-eldoc-get-breadcrumb-no-properties (string)
  "Remove properties from STRING."
  (when string (substring-no-properties string)))
(advice-add 'org-eldoc-get-breadcrumb :filter-return #'+org-eldoc-get-breadcrumb-no-properties)
#+end_src

**** Tables
#+begin_src emacs-lisp :tangle yes
(use-package valign
  :ensure t
  :hook
  (org-mode . valign-mode)
  :custom
  (valign-fancy-bar t))
#+end_src

*** Export
**** LaTeX
Disable link colors.
#+begin_src emacs-lisp :tangle yes
(use-package ox-latex
  :custom
  (org-latex-hyperref-template
   (mapconcat
    'identity
    '("\\hypersetup{"
      "pdfauthor={%a},"
      "pdftitle={%t},"
      "pdfkeywords={%k},"
      "pdfsubject={%d},"
      "pdfcreator={%c},"
      "pdflang={%L},"
      "pdfborder=0 0 0}")
    "\n")))
#+end_src

Add links in footnotes.
#+begin_src emacs-lisp :tangle yes
(defvar org-export-latex-add-link-footnotes t
  "If non-nil links will be added as footnotes if exported to latex.")

(defun org-export-latex-link-footnote (text backend _info)
  "Create a footnote for each link to retain this information for print.
If there is a URL and the export BACKEND is latex, then extract
URL into footnote from TEXT."
  (when (and org-export-latex-add-link-footnotes
             (org-export-derived-backend-p backend 'latex)
             (string-match "\\\\href{\\(.*\\)}{\\(.*\\)}" text))
    (when (cl-some (lambda (type)
                     (string-prefix-p type (match-string 1 text)))
                   '("http" "https" "ftp" "mailto" "doi"))
      (format "%s \\footnote{\\url{%s}} " text (match-string 1 text)))))

(with-eval-after-load 'ox
  (cl-pushnew #'org-export-latex-link-footnote org-export-filter-link-functions :test #'equal))
#+end_src

** outline
Display outlines in text like files or use it in conjunction with other major modes via ~outline-minor-mode~.
*** Packages
**** outline-minor-faces
Add faces to =outline-minor-mode= in order to make the headings stand out.
#+begin_src emacs-lisp :tangle yes
(use-package outline-minor-faces
  :ensure t
  :after outline
  :hook
  (outline-minor-mode . outline-minor-faces-add-font-lock-keywords))
#+end_src

** clojure
#+begin_src emacs-lisp :tangle yes
(use-package clojure-mode
  :ensure t
  :mode
  "\\.\\(clj\\|dtm\\|edn\\)\\'"
  "\\(?:build\\|profile\\)\\.boot\\'"
  ("\\.cljc\\'" . clojurec-mode)
  ("\\.cljs\\'" . clojurescript-mode))
#+end_src

*** Packages
**** cider
#+begin_src emacs-lisp :tangle yes
(use-package cider
  :ensure t
  :hook
  (cider-mode . cider-auto-test-mode)
  :custom
  (cider-prompt-for-symbol nil)
  (cider-repl-display-help-banner nil)
  (cider-repl-history-file (concat data-dir "cider-history"))
  (org-babel-clojure-backend 'cider)
  :general
  (:keymaps
   'cider-mode-map
   :prefix local-leader-key
   "c" 'cider-refresh
   "t" 'cider-test-run-test
   "T" 'cider-test-run-ns-tests
   "s" 'cider-test-run-project-tests))
#+end_src

** crystal
#+begin_src emacs-lisp :tangle yes
(use-package crystal-mode
  :ensure t
  :mode "\\(?:\\.cr\\)\\'"
  :general
  (:keymaps
   'crystal-mode-map
   :prefix local-leader-key
   "t" 'crystal-spec-line
   "T" 'crystal-spec-buffer
   "s" 'crystal-spec-all))
#+end_src

*** Packages
**** inf-crystal
#+begin_src emacs-lisp :tangle yes
(use-package inf-crystal
  :ensure t
  :hook
  (crystal-mode . inf-crystal-minor-mode)
  :general
  (:keymaps
   'crystal-mode-map
   :prefix local-leader-key
   "r" 'inf-crystal))
#+end_src

** csv
#+begin_src emacs-lisp :tangle yes
(use-package csv-mode
  :ensure t
  :mode
  "\\.[Cc][Ss][Vv]\\'"
  ("\\.tsv\\'" . tsv-mode)
  :custom
  (csv-separators '("," "\t" ";")))
#+end_src

** elasticsearch
#+begin_src emacs-lisp :tangle yes
(use-package es-mode
  :ensure t
  :mode "\\.es\\'")
#+end_src

** elixir
#+begin_src emacs-lisp :tangle yes
(use-package elixir-mode
  :ensure t
  :mode
  "\\.elixir\\'"
  "\\.ex\\'"
  "\\.exs\\'")
#+end_src

*** Packages
**** alchemist
#+begin_src emacs-lisp :tangle yes
(use-package alchemist
  :ensure t
  :hook
  (elixir-mode . alchemist-mode)
  :general
  (:keymaps
   'alchemist-mode-map
   :prefix nav-prefix
   "k" 'alchemist-help-search-at-point)
  (:keymaps
   'alchemist-mode-map
   :prefix local-leader-key
   "r" 'alchemist-iex-run
   "s" 'alchemist-mix-test
   "t" 'alchemist-mix-test-at-point
   "T" 'alchemist-mix-test-this-buffer))
#+end_src

** elm
#+begin_src emacs-lisp :tangle yes
(use-package elm-mode
  :ensure t
  :mode "\\.elm\\'"
  :custom
  (elm-format-on-save t)
  (elm-package-json "elm.json")
  (elm-tags-exclude-elm-stuff nil)
  (elm-tags-on-save t)
  :general
  (:keymaps
   'elm-mode-map
   :prefix local-leader-key
   "t" 'elm-test-project))
#+end_src

** epub
*** Packages
**** nov
#+begin_src emacs-lisp :tangle yes
(use-package nov
  :ensure t
  :mode
  ("\\.epub\\'" . nov-mode)
  :hook
  (nov-mode . init-nov-delayed-render)
  (nov-mode . init-nov-fringes)
  :custom
  (nov-save-place-file (concat data-dir "nov-places"))
  :preface
  (defun init-nov-delayed-render ()
    (run-with-idle-timer 0.2 nil 'nov-render-document))

  (defun init-nov-fringes ()
    "Hide the fringes for `nov-mode'."
    (set-window-fringes (get-buffer-window) 0 0 nil)))
#+end_src

** erlang
#+begin_src emacs-lisp :tangle yes
(use-package erlang
  :ensure t
  :mode
  "\\.erl$"
  "\\.app\\.src$"
  "\\.escript"
  "\\.hrl$"
  "\\.xrl$"
  "\\.yrl"
  "/ebin/.+\\.app"
  :hook
  (erlang-mode . init-erlang-eunit)
  (erlang-mode . init-erlang-flymake)
  :general
  (:keymaps
   'erlang-mode-map
   :prefix nav-prefix
   "k" 'erlang-man-function)
  (:keymaps
   'erlang-mode-map
   :prefix local-leader-key
   "t" 'erlang-eunit-compile-and-run-current-test
   "T" 'erlang-eunit-compile-and-run-module-tests
   "r" 'erlang-shell-display)
  :preface
  (defun init-erlang-eunit ()
    "Setup EUnit support for `erlang-mode'."
    (require 'erlang-eunit))
  (defun init-erlang-flymake ()
    "Setup `flymake' support for `erlang-mode'."
    (require 'erlang-flymake)
    (flymake-mode 1)))
#+end_src

** git
*** Packages
**** gitignore-mode
#+begin_src emacs-lisp :tangle yes
(use-package gitignore-mode
  :ensure t
  :mode "/\\.dockerignore\\'")
#+end_src

** go
#+begin_src emacs-lisp :tangle yes
(use-package go-mode
  :ensure t
  :mode
  "\\.go\\'"
  ("go\\.mod\\'" . go-dot-mod-mode)
  :custom
  (gofmt-command "goimports")
  :general
  (:keymaps
   'go-mode-map
   :prefix nav-prefix
   "k" 'godoc-at-point))
#+end_src

*** Packages
**** go-eldoc
#+begin_src emacs-lisp :tangle yes
(use-package go-eldoc
  :ensure t
  :hook
  (go-mode . go-eldoc-setup))
#+end_src

**** gorepl-mode
#+begin_src emacs-lisp :tangle yes
(use-package gorepl-mode
  :ensure t
  :hook
  (go-mode . gorepl-mode))
#+end_src

** groovy
#+begin_src emacs-lisp :tangle yes
(use-package groovy-mode
  :ensure t
  :mode
  "\\.g\\(?:ant\\|roovy\\|radle\\)\\'"
  "Jenkinsfile")
#+end_src

** fish
#+begin_src emacs-lisp :tangle yes
(use-package fish-mode
  :ensure t
  :mode
  "\\.fish\\'"
  "/fish_funced\\..*\\'")
#+end_src

** haskell
#+begin_src emacs-lisp :tangle yes
(use-package haskell-mode
  :ensure t
  :mode
  "\\.[gh]s\\'"
  "\\.hsig\\'"
  "\\.hsc\\'"
  ("\\.cabal\\'\\|/cabal\\.project\\|/\\.cabal/config\\'" . haskell-cabal-mode)
  ("\\.l[gh]s\\'" . haskell-literate-mode)
  :hook
  (haskell-mode . interactive-haskell-mode)
  :custom
  (haskell-font-lock-symbols t)
  (haskell-process-auto-import-loaded-modules t)
  (haskell-process-log t)
  (haskell-process-show-debug-tips nil)
  (haskell-process-use-presentation-mode t)
  (haskell-stylish-on-save t)
  (haskell-mode-stylish-haskell-path "brittany")
  :general
  (:keymaps
   'interactive-haskell-mode-map
   "M-." 'nil)
  (:keymaps
   'haskell-mode-map
   :prefix local-leader-key
   "r" 'haskell-interactive-switch
   "R" 'haskell-session-change-target)
  :init
  ;; Allow configuring project local cabal repl commands.
  (put 'haskell-process-args-cabal-repl 'safe-local-variable (lambda (x) (seq-every-p #'stringp x))))
#+end_src

*** REPL
Persist REPL history.
#+begin_src emacs-lisp :tangle yes
(use-package haskell-mode
  :hook
  (haskell-interactive-mode . +haskell-interactive-load-history)
  :defines (haskell-interactive-mode-history)
  :preface
  (defvar +haskell-interactive-global-history nil)

  (defun +haskell-interactive-save-history ()
    "Save `haskell-interactive-mode' history."
    (setq +haskell-interactive-global-history haskell-interactive-mode-history))

  (defun +haskell-interactive-load-history ()
    "Restore `haskell-interactive-mode' history."
    (add-hook 'kill-buffer-hook #'+haskell-interactive-save-history nil t)
    (when +haskell-interactive-global-history
      (setq haskell-interactive-mode-history +haskell-interactive-global-history)))
  :config
  (cl-pushnew '+haskell-interactive-global-history savehist-additional-variables :test #'equal))
#+end_src

*** Packages
**** hasky-stack
#+begin_src emacs-lisp :tangle yes
(use-package hasky-stack
  :ensure t
  :general
  (:keymaps
   'haskell-mode-map
   :prefix local-leader-key
   "t" 'hasky-stack-test))
#+end_src

** java
*** Packages
**** gradle-mode
#+begin_src emacs-lisp :tangle yes
(use-package gradle-mode
  :ensure t
  :hook
  ((java-mode kotlin-mode) . gradle-mode)
  :general
  (:keymaps
   'gradle-mode-map
   :prefix local-leader-key
   "t" 'gradle-test))
#+end_src

**** java-lookup
#+begin_src emacs-lisp :tangle yes
(use-package javadoc-lookup
  :ensure t
  :general
  (:keymaps
   'java-mode-map
   :prefix nav-prefix
   "k" 'javadoc-lookup))
#+end_src

** js
#+begin_src emacs-lisp :tangle yes
(use-package js
  :mode
  ("\\.js[mx]?\\'" . javascript-mode)
  ("\\.har\\'" . javascript-mode)
  :hook
  (js-mode . init-js-find-file)
  :preface
  (defun init-js-find-file ()
    "Setup `ff-test-find-other-file' support for `js-mode'."
    (setq ff-test-search-implementation-project-directories '("src")
          ff-test-search-test-directories '("." "__tests__")
          ff-test-search-test-project-directories '("test" "spec" "__tests__"))))
#+end_src

*** Packages
**** flymake-eslint
#+begin_src emacs-lisp :tangle yes
(use-package flymake-eslint
  :ensure t
  :init
  (put 'flymake-eslint-executable-name 'safe-local-variable #'(lambda (x) (member x '("eslint" "eslint_d"))))
  (put 'flymake-eslint-executable-args 'safe-local-variable 'stringp))
#+end_src

**** indium
Debugger
#+begin_src emacs-lisp :tangle yes
(use-package indium
  :ensure t
  :hook
  (js-mode . +indium-interaction-unless-json-mode)
  :commands
  (indium-interaction-mode)
  :preface
  (defun +indium-interaction-unless-json-mode ()
    (unless (derived-mode-p 'json-mode) (indium-interaction-mode)))
  :general
  (:keymaps
   'js-mode-map
   :prefix local-leader-key
   "s" 'indium-scratch
   "o" 'indium-launch
   "O" 'indium-connect)
  (:keymaps
   'indium-debugger-mode
   :definer 'minor-mode
   "RET" 'indium-debugger-step-over))
#+end_src

**** jest
Test framework execution.
#+begin_src emacs-lisp :tangle yes
(use-package jest
  :ensure t
  :general
  (:keymaps
   'js-mode-map
   :prefix local-leader-key
   "t" 'jest-funcion-dwim
   "T" 'jest-file
   "s" 'jest-popup))
#+end_src

**** js2
#+begin_src emacs-lisp :tangle yes
(use-package js2-mode
  :ensure t
  :hook
  (js-mode . js2-minor-mode)
  :custom
  (js2-highlight-external-variables nil)
  (js2-mode-show-parse-errors nil)
  (js2-skip-preprocessor-directives t)
  (js2-strict-missing-semi-warning nil)
  (js2-strict-trailing-comma-warning nil))
#+end_src

**** nodejs-repl
REPL for nodejs.
#+begin_src emacs-lisp :tangle yes
(use-package nodejs-repl :ensure t)
#+end_src

** json
#+begin_src emacs-lisp :tangle yes
(use-package json-mode
  :ensure t
  :mode
  "\\(?:\\(?:\\.json\\|\\.jsonld\\|\\.babelrc\\|\\.bowerrc\\|composer\\.lock\\)\\'\\)"
  :preface
  (defun init-json-mode-flymake ()
    "Setup `json-mode' integration with Flymake."
    (add-hook 'flymake-diagnostic-functions #'flymake-check-jsonlint nil t)
    (flymake-mode))
  :hook
  (json-mode . init-json-mode-flymake))
#+end_src

*** Syntax checker
#+begin_src emacs-lisp :tangle yes
(flymake-quickdef-backend flymake-check-jsonlint
  :pre-let ((jsonlint-exec (executable-find "jsonlint")))
  :pre-check (unless jsonlint-exec (error "Cannot find jsonlint executable"))
  :write-type 'file
  :proc-form (list jsonlint-exec "-c" "-q" fmqd-temp-file)
  :search-regexp "^\\(.+\\)\: line \\([0-9]+\\), col \\([0-9]+\\), \\(.+\\)$"
  :prep-diagnostic
  (let* ((lnum (string-to-number (match-string 2)))
         (col (string-to-number (match-string 3)))
         (msg (match-string 4))
         (pos (flymake-diag-region fmqd-source lnum col))
         (beg (car pos))
         (end (cdr pos))
         (type :error))
    (list fmqd-source beg end type msg)))
#+end_src

*** Packages
**** json-navigator
#+begin_src emacs-lisp :tangle yes
(use-package json-navigator
  :ensure t
  :general
  (:keymaps
   'json-mode-map
   :prefix local-leader-key
   "n" 'json-navigator-navigate-region))
#+end_src

** kotlin
#+begin_src emacs-lisp :tangle yes
(use-package kotlin-mode :ensure t)
#+end_src

** lisp
*** Packages
**** slime
#+begin_src emacs-lisp :tangle yes
(use-package slime
  :ensure t
  :hook
  (lisp-mode . slime-mode)
  :custom
  (inferior-lisp-program "sbcl")
  (slime-contribs '(slime-fancy slime-repl))
  :general
  (:keymaps
   'slime-mode-map
   :prefix nav-prefix
   "k" 'slime-describe-symbol)
  (:keymaps
   'slime-mode-map
   :prefix local-leader-key
   "o" 'slime
   "t" 'slime-load-file-and-other-file)
  :preface
  (defun slime-load-file-and-other-file ()
    "Load buffer file and then load other (test) file."
    (interactive)
    (dolist (file `(,buffer-file-name ,(ff-test-other-file-name)))
      (when (and file (file-exists-p file))
        (slime-load-file file)))))
#+end_src

** lua
#+begin_src emacs-lisp :tangle yes
(use-package lua-mode
  :ensure t
  :mode "\\.lua\\'"
  :custom
  (lua-documentation-function 'eww)
  :general
  (:keymaps
   'lua-mode-map
   :prefix nav-prefix
   "k" 'lua-search-documentation))
#+end_src

** markdown
#+begin_src emacs-lisp :tangle yes
(use-package markdown-mode
  :ensure t
  :mode
  "\\.markdown\\'"
  "\\.md\\'"
  :hook
  (markdown-mode . auto-fill-mode)
  :custom
  (markdown-enable-wiki-links t)
  (markdown-fontify-code-blocks-natively t)
  (markdown-header-scaling t)
  (markdown-hide-markup t)
  (markdown-italic-underscore t)
  (markdown-blockquote-display-char '("┃" ">"))
  (markdown-list-item-bullets '("⏺" "▪"))
  (markdown-make-gfm-checkboxes-buttons t)
  :general
  (:keymaps
   'markdown-mode-map
   :prefix local-leader-key
   "v" 'markdown-toggle-markup-hiding))
#+end_src

*** Packages
**** edit-indirect
Editing regions in separate buffers.
#+begin_src emacs-lisp :tangle yes
(use-package edit-indirect :ensure t)
#+end_src

**** markdown-toc
Generate Table of Contents.
#+begin_src emacs-lisp :tangle yes
(use-package markdown-toc :ensure t)
#+end_src

*** Appearance
**** Variable pitch
Use variable-pitch font but still make sure everything aligns.
#+begin_src emacs-lisp :tangle yes
(font-lock-add-keywords
 'markdown-mode
 '(("^[[:space:]-*+>]+" 0 'fixed-pitch append))
 'append)
#+end_src

**** Bullet lists
Pretty check-boxes
#+begin_src emacs-lisp :tangle yes
(font-lock-add-keywords
 'markdown-mode
 '(("^ *[-*+] \\[\\([Xx]\\)\\] "
    (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "✕"))))))
#+end_src

** message
#+begin_src emacs-lisp :tangle yes
(use-package message
  :custom
  (message-expand-name-standard-ui t))
#+end_src

** nginx
#+begin_src emacs-lisp :tangle yes
(use-package nginx-mode
  :ensure t
  :mode
  "/nginx/.+\\.conf\\'"
  "nginx\\.conf\\'")
#+end_src

** nix
#+begin_src emacs-lisp :tangle yes
(use-package nix-mode
  :ensure t
  :mode "\\.nix\\'")
#+end_src

*** Packages
**** nix-update
#+begin_src emacs-lisp :tangle yes
(use-package nix-update
  :ensure t
  :general
  (:keymaps
   'nix-mode-map
   :prefix local-leader-key
   "u" 'nix-update-fetch))
#+end_src

** nxml
#+begin_src emacs-lisp :tangle yes
(use-package nxml-mode
  :mode "\\.plist\\'"
  :custom
  (nxml-slash-auto-complete-flag t)
  :config
  (with-eval-after-load 'smartparens
    (sp-local-pair '(nxml-mode) "<" ">" :actions :rem)))
#+end_src

** ocaml
#+begin_src emacs-lisp :tangle yes
(use-package caml :ensure t)

(use-package tuareg
  :ensure t
  :general
  (:keymaps
   'tuareg-mode-map
   "C-x C-e" 'tuareg-eval-phrase)
  (:keymaps
   'tuareg-mode-map
   :prefix local-leader-key
   "r" 'run-ocaml))
#+end_src

** pdf
*** Packages
**** pdf-tools
#+begin_src emacs-lisp :tangle yes
(use-package pdf-tools
  :ensure t
  :mode ("\\.pdf\\'" . pdf-view-mode))
#+end_src

** plantuml
#+begin_src emacs-lisp :tangle yes
(use-package plantuml-mode
  :ensure t
  :mode "\\.\\(plantuml\\|pum\\|plu\\)\\'"
  :custom
  (plantuml-default-exec-mode 'executable))
#+end_src

** protobuf
#+begin_src emacs-lisp :tangle yes
(use-package protobuf-mode
  :ensure t
  :mode "\\.proto\\'")
#+end_src

** python
#+begin_src emacs-lisp :tangle yes
(use-package python
  :ensure t
  :general
  (:keymaps
   'python-mode-map
   :prefix local-leader-key
   "r" 'run-python)
  :config
  (put 'python-shell-interpreter 'safe-local-variable #'(lambda (x) (member x '("python" "ipython")))))
#+end_src

*** Packages
**** pydoc
#+begin_src emacs-lisp :tangle yes
(use-package pydoc
  :ensure t
  :general
  (:keymaps
   'python-mode-map
   :prefix nav-prefix
   "k" 'pydoc-at-point))
#+end_src

**** python-test
#+begin_src emacs-lisp :tangle yes
(use-package python-test
  :ensure t
  :custom
  (python-test-backend 'pytest)
  :general
  (:keymaps
   'python-mode-map
   :prefix local-leader-key
   "t" 'python-test-project)
  :config
  (setq python-test-project-root-files
        (append '("README.md") python-test-project-root-files)))
#+end_src

** racket
#+begin_src emacs-lisp :tangle yes
(use-package racket-mode
  :ensure t
  :mode "\\.rkt[dl]?\\'"
  :general
  (:keymaps
   'racket-mode-map
   :prefix nav-prefix
   "k" 'racket-doc)
  (:keymaps
   'racket-mode-map
   :prefix local-leader-key
   "t" 'racket-test))
#+end_src

*** Packages
**** flymake-racket
#+begin_src emacs-lisp :tangle yes
(use-package flymake-racket
  :ensure t
  :hook
  (racket-mode . flymake-racket-add-hook))
#+end_src

** rst
#+begin_src emacs-lisp :tangle yes
(use-package rst
  :hook
  (rst-mode . auto-fill-mode)
  :preface
  (defvar rst-adornment-regexp nil
    "Regular expression to match adornments.")
  :config
  (setq rst-adornment-regexp
        (concat "^[" rst-adornment-chars "]\\{3,\\}$")))
#+end_src

*** Appearance
**** Variable pitch
Use variable-pitch font but still make sure everything aligns.
#+begin_src emacs-lisp :tangle yes
(font-lock-add-keywords
 'rst-mode
 '(("^[[:space:]-*+]+\\(\\[.\\]\\)?" 0 'fixed-pitch append))
 'append)
#+end_src

**** Heading
Hide heading adornments.
#+begin_src emacs-lisp :tangle yes
(defun +rst-hide-heading-adornment ()
  "Hide heading adornment for `rst-mode'."
  (interactive)
  (hide-lines-matching rst-adornment-regexp))
(add-hook 'rst-mode-hook #'+rst-hide-heading-adornment)
#+end_src

**** Bullet lists
Pretty check-boxes as well as bullet lists.
#+begin_src emacs-lisp :tangle yes
(font-lock-add-keywords
 'rst-mode
 '(("^ *\\([-*+]\\) "
    (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "⏺"))))
   ("^ *[-*+] \\[\\([Xx]\\)\\] "
    (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "✕"))))))
#+end_src

** ruby
#+begin_src emacs-lisp :tangle yes
(use-package ruby-mode
  :hook
  (ruby-mode . init-ruby-find-file)
  :custom
  (ruby-align-chained-calls t)
  :preface
  (defun init-ruby-find-file ()
    "Setup `ff-test-find-other-file' support for `ruby-mode'."
    (setq ff-test-suffixes '("_test" "_spec")
          ff-test-search-implementation-project-directories '("app" "lib")
          ff-test-search-test-project-directories '("test" "spec")))
  :config
  (with-eval-after-load 'hideshow
    (cl-pushnew `(ruby-mode
                  ,(rx (or "def" "class" "module" "do" "{" "[")) ; Block start
                  ,(rx (or "}" "]" "end"))                       ; Block end
                  ,(rx bol
                       (or (+ (zero-or-more blank) "#") "=begin")) ; Comment start
                  ruby-forward-sexp nil)
                hs-special-modes-alist
                :test #'equal)))
#+end_src

*** Testing
#+begin_src emacs-lisp :tangle yes
(defun ruby-test-all ()
  "Test all files using either RSpec or MiniTest."
  (interactive)
  (if (bound-and-true-p rspec-mode)
      (rspec-verify-all)
    (minitest-verify-all)))

(defun ruby-test-file ()
  "Test current file using either RSpec or MiniTest."
  (interactive)
  (if (bound-and-true-p rspec-mode)
      (rspec-verify)
    (minitest-verify)))

(defun ruby-test-at-point ()
  "Test definition at point using either RSpec or MiniTest."
  (interactive)
  (if (bound-and-true-p rspec-mode)
      (rspec-verify-single)
    (minitest-verify-single)))

(general-define-key
 :keymaps 'ruby-mode-map
 :prefix local-leader-key
 "t" 'ruby-test-at-point
 "T" 'ruby-test-file
 "s" 'ruby-test-all)
#+end_src

*** Packages
**** inf-ruby
#+begin_src emacs-lisp :tangle yes
(use-package inf-ruby
  :ensure t
  :hook
  (ruby-mode . inf-ruby-minor-mode)
  ;; Auto breakpoint
  (compilation-filter . inf-ruby-auto-enter)
  :custom
  (inf-ruby-default-implementation "pry")
  :general
  (:keymaps
   'ruby-mode-map
   :prefix local-leader-key
   "r" 'inf-ruby))
#+end_src

**** minitest
#+begin_src emacs-lisp :tangle yes
(use-package minitest
  :ensure t
  :hook
  (ruby-mode . minitest-enable-appropriate-mode))
#+end_src

**** rake
#+begin_src emacs-lisp :tangle yes
(use-package rake
  :ensure t
  :custom
  (rake-completion-system 'default)
  (rake-cache-file (expand-file-name "rake.cache" cache-dir)))
#+end_src

**** rspec-mode
#+begin_src emacs-lisp :tangle yes
(use-package rspec-mode
  :ensure t
  :hook
  (ruby-mode . rspec-enable-appropriate-mode)
  :custom
  (rspec-use-relative-path t)
  (rspec-use-opts-file-when-available nil)
  (rspec-command-options "--format progress"))
#+end_src

**** ruby-refactor
#+begin_src emacs-lisp :tangle yes
(use-package ruby-refactor
  :ensure t
  :hook
  (ruby-mode . ruby-refactor-mode))
#+end_src

**** yard-mode
#+begin_src emacs-lisp :tangle yes
(use-package yard-mode
  :ensure t
  :hook ruby-mode)
#+end_src

**** yari
#+begin_src emacs-lisp :tangle yes
(use-package yari
  :ensure t
  :general
  (:keymaps
   'ruby-mode-map
   :prefix nav-prefix
   "k" 'yari)
  (:keymaps
   'help-command-map
   "R" 'yari))
#+end_src

** rust
#+begin_src emacs-lisp :tangle yes
(use-package rustic
  :ensure t
  :mode
  ("\\.rs\\'" . rustic-mode)
  :custom
  (rustic-rls-pkg 'eglot)
  :general
  (:keymaps
   'rustic-mode-map
   :prefix local-leader-key
   "t" 'rustic-cargo-test)
  :init
  (with-eval-after-load 'org
    (cl-pushnew '("rust" . rustic) org-src-lang-modes :test #'equal))
  :config
  (require 'eglot))
#+end_src

** scala
#+begin_src emacs-lisp :tangle yes
(use-package scala-mode
  :ensure t
  :mode "\\.\\(scala\\|sbt\\)\\'"
  :hook
  (scala-mode . init-scala-prettify-symbols)
  :custom
  (scala-indent:align-parameters t)
  :preface
  (defun init-scala-prettify-symbols ()
    (setq prettify-symbols-alist scala-prettify-symbols-alist)
    (prettify-symbols-mode 1)))
#+end_src

*** Packages
**** sbt-mode
#+begin_src emacs-lisp :tangle yes
(use-package sbt-mode :ensure t)
#+end_src

** sh
#+begin_src emacs-lisp :tangle yes
(use-package sh-script
  :custom
  ;; Use regular indentation for line-continuation
  (sh-indent-after-continuation 'always)
  :general
  (:keymaps
   'sh-mode-map
   :prefix nav-prefix
   "k" 'man))
#+end_src

*** Packages
**** flymake-shellcheck
#+begin_src emacs-lisp :tangle yes
(use-package flymake-shellcheck
  :ensure t
  :hook
  (sh-mode . flymake-mode)
  (sh-mode . flymake-shellcheck-load))
#+end_src

** sql
#+begin_src emacs-lisp :tangle yes
(use-package sql
  :custom
  (sql-mysql-options '("--protocol=tcp" "--prompt=" "--disable-pager")))
#+end_src

** typescript
#+begin_src emacs-lisp :tangle yes
(use-package typescript-mode
  :ensure t
  :mode "\\.ts$"
  :hook
  (typescript-mode . init-typescript-find-file)
  :general
  (:keymaps
   'typescript-mode-map
   "C-c '" 'nil)
  :preface
  (defun init-typescript-find-file ()
    "Setup `ff-test-find-other-file' support for `typescript-mode'."
    (setq ff-test-search-implementation-project-directories '("src")
          ff-test-search-test-directories '("." "__tests__")
          ff-test-search-test-project-directories '("test" "spec" "__tests__"))))
#+end_src

*** Packages
**** ts-comint
TypeScript REPL.
#+begin_src emacs-lisp :tangle yes
(use-package ts-comint
  :ensure t
  :custom
  (ts-comint-program-command "ts-node"))
#+end_src

**** jest
Test framework execution.
#+begin_src emacs-lisp :tangle yes
(use-package jest
  :ensure t
  :general
  (:keymaps
   'typescript-mode-map
   :prefix local-leader-key
   "t" 'jest-function-dwim
   "T" 'jest-file
   "s" 'jest-popup))
#+end_src

** web
*** Packages
**** cakecrumbs
Display current path for HTML/XML/CSS.
#+begin_src emacs-lisp :tangle yes
(use-package cakecrumbs
  :ensure t
  :functions
  (cakecrumbs-auto-setup)
  :config
  (cakecrumbs-auto-setup))
#+end_src

**** web-mode
#+begin_src emacs-lisp :tangle yes
(use-package web-mode
  :ensure t
  :mode "\\.\\(phtml\\|php\\|[agj]sp\\|as[cp]x\\|erb\\|djhtml\\|html?\\|hbs\\|ejs\\|jade\\|swig\\|tmpl\\)\\'"
  :custom
  (web-mode-enable-html-entities-fontification t)
  ;; Highlight enclosing tags of the element under cursor
  (web-mode-enable-current-element-highlight t)
  ;; No extra indentation for blocks.
  (web-mode-script-padding 0)
  (web-mode-style-padding 0))
#+end_src

** yaml
#+begin_src emacs-lisp :tangle yes
(use-package yaml-mode
  :ensure t
  :mode "\\.\\(e?ya?\\|ra\\)ml\\'"
  :hook (yaml-mode . indent-guide-mode))
#+end_src

* Tools
** E-mail
*** Packages
**** bbdb
Store contacts.
#+begin_src emacs-lisp :tangle yes
(use-package bbdb :ensure t)
#+end_src

**** gmail2bbdb
Import contacts from Gmail vCard data.
#+begin_src emacs-lisp :tangle yes
(use-package gmail2bbdb
  :ensure t
  :config
  (setq gmail2bbdb-bbdb-file bbdb-file
        gmail2bbdb-exclude-people-without-name t))
#+end_src

** Focus
Dim out the surrounding text except the current focused paragraph or expression.
#+begin_src emacs-lisp :tangle yes
(use-package focus :ensure t)
#+end_src

** Indentation guides
#+begin_src emacs-lisp :tangle yes
(use-package indent-guide
  :ensure t
  :custom
  (indent-guide-char "\x2502"))
#+end_src

** Pomodoro
#+begin_src emacs-lisp :tangle yes
(use-package redtick
  :ensure t
  :general
  (:prefix
   launch-prefix
   "r" 'redtick))
#+end_src

** Session
Support for restoring previous session on Emacs restart. This adds a few tweaks that makes
it really useful.
- Support for persistent undo history via ~buffer-undo-list~.
- Ignore saving of =gz= files as it seems not to properly load those.
- Restore no buffers to begin with to avoid slow starts with huge sessions.
#+begin_src emacs-lisp :tangle yes
(use-package desktop
  :demand t
  :custom
  (desktop-files-not-to-save "\\(\\`/[^/:]*:\\|(ftp)\\|\\.gz\\'\\)")
  (desktop-restore-eager 0)
  (desktop-save (daemonp))
  (desktop-load-locked-desktop (daemonp))
  :config
  (dolist (var '(buffer-undo-list ivy-views))
    (cl-pushnew var desktop-locals-to-save :test #'equal))
  (desktop-save-mode 1))
#+end_src

** Speed reading
#+begin_src emacs-lisp :tangle yes
(use-package spray
  :ensure t
  :custom
  (spray-height 500)
  (spray-margin-left 2)
  :config
  (setq spray-unsupported-minor-modes
        (append '(beacon-mode centered-window-mode visual-fill-column-mode)
                spray-unsupported-minor-modes))
  :general
  (:prefix
   launch-prefix
   "s" 'spray-mode))
#+end_src

** Spell checking
#+begin_src emacs-lisp :tangle yes
(use-package flyspell
  :hook
  ((message-mode org-mode text-mode) . flyspell-mode)
  (prog-mode . flyspell-prog-mode)
  :custom
  (flyspell-persistent-highlight nil)
  :general
  (:keymaps
   'flyspell-mode-map
   "C-," 'nil
   "C-." 'nil))
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package flyspell-correct
  :ensure t
  :general
  (:keymaps
   'flyspell-mode-map
   "C-;" 'flyspell-correct-wrapper))
#+end_src

Automatically infer dictionary.
#+begin_src emacs-lisp :tangle yes
(use-package auto-dictionary
  :ensure t
  :commands
  (adict-mode))
#+end_src

** Terminal
*** Pager
Make less work inside Emacs shells. But disable it as the default pager.
#+begin_src emacs-lisp :tangle yes
(setenv "LESS" "--dumb --prompt=s")
(setenv "PAGER" "")
#+end_src

*** eshell
#+begin_src emacs-lisp :tangle yes
(use-package eshell
  :hook
  (eshell-mode . abbrev-mode)
  (eshell-mode . init-eshell-define-keys)
  (eshell-mode . init-eshell-set-visual-commands)
  :custom
  (eshell-buffer-maximum-lines 20000)
  (eshell-history-size 1000)
  (eshell-hist-ignoredups t)
  (eshell-error-if-no-glob t)
  (eshell-destroy-buffer-when-process-dies t)
  :general
  ("C-!" 'eshell)
  (:prefix
   launch-prefix
   "t" 'eshell)
  :preface
  (defvar eshell-visual-commands)
  (defun init-eshell-define-keys ()
    (general-define-key
     :keymaps 'eshell-mode-map
     "RET" '+eshell-expand-abbrev-and-send-input
     "<tab>" 'completion-at-point
     "C-r" 'counsel-esh-history))

  (defun init-eshell-set-visual-commands ()
    (setq eshell-visual-commands
          (append
           '("fish" "ghcid" "jshell" "most" "ssh" "tail" "tsun" "watch")
           eshell-visual-commands)))
  :init
  (autoload 'eshell-smart-initialize "em-smart"))
#+end_src

**** Abbreviations
Fish-like abbreviations that expand on space or enter.
#+begin_src emacs-lisp :tangle yes
(defun +eshell-expand-abbrev-and-send-input ()
  "Expand abbreviation and send input to `eshell'."
  (interactive)
  (expand-abbrev)
  (call-interactively #'eshell-send-input))

(defun +eshell-abbrev-expand-p ()
  "Return t if abbreviation should be expanded.
Expansion should happen when abbreviation is at the beginning of
the line or after an eshell operator."
  (let* ((end (point-marker))
         (begin (save-excursion (eshell-bol) (point)))
         (args (catch 'eshell-incomplete (eshell-parse-arguments begin end))))
    (or (= 1 (length args))
        (let ((last-two-args (last args 2)))
          (and (consp (car last-two-args))
               (eq (caar last-two-args)
                   'eshell-operator))))))

(define-abbrev-table 'eshell-mode-abbrev-table
  '(("base64" "base64 -w0")
    ("d" "docker")
    ("dim" "docker images")
    ("dp" "docker ps")
    ("dc" "docker-compose")
    ("dcl" "docker-compose logs")
    ("e" "find-file-other-window")
    ("E" "dired")
    ("gd" "magit-diff-unstaged")
    ("gds" "magit-diff-staged")
    ("gs" "magit-status")
    ("time" "time -p")
    ("tree" "tree -a")
    ("week" "date '+%V'"))
  :enable-function #'+eshell-abbrev-expand-p)
#+end_src

**** Packages
***** eshell-fringe-status
Command execution status indicator in the fringe.
#+begin_src emacs-lisp :tangle yes
(use-package eshell-fringe-status
  :ensure t
  :hook
  (eshell-mode . eshell-fringe-status-mode))
#+end_src

***** esh-autosuggest
Autosuggestions from history similar to fish.
#+begin_src emacs-lisp :tangle yes
(use-package esh-autosuggest
  :ensure t
  :hook
  (eshell-mode . esh-autosuggest-mode)
  :general
  (:keymaps
   'esh-autosuggest-active-map
   "C-e" 'company-complete-selection))
#+end_src

***** fish-completion
Populate auto-completions from fish.
#+begin_src emacs-lisp :tangle yes
(use-package fish-completion
  :ensure t
  :hook
  (eshell-mode . fish-completion-mode))
#+end_src

*** vterm
Fast terminal emulator utilizing =libvterm=.
#+begin_src emacs-lisp :tangle yes
(use-package vterm
  :ensure t
  :custom
  (vterm-shell "fish")
  :general
  (:prefix
   launch-prefix
   "T" 'vterm))
#+end_src

**** Packages
***** vterm-toggle
#+begin_src emacs-lisp :tangle yes
(use-package vterm-toggle
  :ensure t
  :general
  ("C-M-!" 'vterm-toggle)
  (:keymaps
   'vterm-mode-map
   "C-<return>" 'vterm-toggle-insert-cd))
#+end_src

** Undo
Navigate through undo history.
#+begin_src emacs-lisp :tangle yes
(use-package undo-propose
  :ensure t
  :general
  (:prefix
   launch-prefix
   "u" 'undo-propose))
#+end_src

* Testing
Packages that I am currently testing or evaluating.

** adaptive-wrap
#+begin_src emacs-lisp :tangle yes
(use-package adaptive-wrap :ensure t)
#+end_src

** annotate
#+begin_src emacs-lisp :tangle yes
(use-package annotate :ensure t)
#+end_src

** awscli-capf
#+begin_src emacs-lisp :tangle yes
(use-package awscli-capf :ensure t)
#+end_src

** comment-or-uncomment-sexp
#+begin_src emacs-lisp :tangle yes
(use-package comment-or-uncomment-sexp :ensure t)
#+end_src

** company-fuzzy
#+begin_src emacs-lisp :tangle yes
(use-package company-fuzzy :ensure t)
#+end_src

** consult
#+begin_src emacs-lisp :tangle yes
(use-package consult
  :ensure t
  :commands (consult-preview-mode)
  :general
  ("M-y" 'consult-yank-pop
   "C-c r" 'consult-recent-file)
  :config
  (consult-preview-mode 1))
(use-package consult-selectrum :ensure t :demand t)
#+end_src

** eglot-x
#+begin_src emacs-lisp :tangle yes
(use-package eglot-x :ensure t)
#+end_src

** ejira
#+begin_src emacs-lisp :tangle yes
(use-package ejira :ensure t)
#+end_src

** elfeed
#+begin_src emacs-lisp :tangle yes
(use-package elfeed :ensure t)
#+end_src

** elsa
#+begin_src emacs-lisp :tangle yes
(use-package elsa :disabled t)
#+end_src

** embark
#+begin_src emacs-lisp :tangle yes
(use-package embark :ensure t)
#+end_src

** fit-text-scale
#+begin_src emacs-lisp :tangle yes
(use-package fit-text-scale :ensure t)
#+end_src

** format-all
#+begin_src emacs-lisp :tangle yes
(use-package format-all :ensure t)
#+end_src

** freeze-it
#+begin_src emacs-lisp :tangle yes
(use-package freeze-it :ensure t)
#+end_src

** marginalia
#+begin_src emacs-lisp :tangle yes
(use-package marginalia :ensure t)
#+end_src

** messages-are-flowing
#+begin_src emacs-lisp :tangle yes
(use-package messages-are-flowing :ensure t)
#+end_src

** multicolumn
#+begin_src emacs-lisp :tangle yes
(use-package multicolumn :ensure t)
#+end_src

** native-complete
#+begin_src emacs-lisp :tangle yes
(use-package native-complete :ensure t)
#+end_src

** org-fragtog
#+begin_src emacs-lisp :tangle yes
(use-package org-fragtog :ensure t)
#+end_src

** org-roam
#+begin_src emacs-lisp :tangle yes
(use-package org-roam :ensure t)
#+end_src

** shrface
#+begin_src emacs-lisp :tangle yes
(use-package shrface :ensure t)
#+end_src

** terraform-doc
#+begin_src emacs-lisp :tangle yes
(use-package terraform-doc :ensure t)
#+end_src

** theme-magic
#+begin_src emacs-lisp :tangle yes
(use-package theme-magic :ensure t)
#+end_src

** virtual-auto-fill
#+begin_src emacs-lisp :tangle yes
(use-package virtual-auto-fill :ensure t)
#+end_src

** webkit
#+begin_src emacs-lisp :tangle yes
(use-package webkit :ensure t)
#+end_src

* Private
#+begin_src emacs-lisp :tangle yes
(require 'private nil t)
#+end_src

* Tasks
** TODO Look into skewer packages
** TODO Look into modal editing with ~objed~
** TODO Look into generic code execution via =isend-mode=
** TODO Look into ~set-selective-display~
** TODO Look into ~semantic-decoration-mode~
** TODO Add binding for org-noter
** TODO Group editing bindings under some logical prefix
** TODO Improve window keys
** TODO Improve find char keys
** TODO Extract history persistance code (persistory)
- comint
- ielm (via comint and savehist)
- haskell-interactive (via savehist)
** TODO Enable auto-revert/save again?
** TODO Wrap lines by default?
- When writing code on a single line, to later let it be expanded by the formatter.
** TODO Only scale images that are larger than size X in org mode
** TODO Use ~ielm~ as REPL for org-mode
** TODO Use file-name as base for work-log date
** TODO Daily tasks
** TODO Write ghq tool using ~completing-read~
** TODO Use =windmove=? Perhaps with ~windmove-create-window t~
** TODO Evaluate if I need projectile, I only use it for other file and project eshell
** TODO Use ~vc-mode~ commands more =C-x v g=, =C-x v v= and =C-x v ==.
- Also ~vc-dir~ and the ~vc-git-stash~ (can stash individual files)
- Diff merge-base =C-x v M D=, =C-x v M L=
- ~vc-log-search~
** TODO Use ChangeLog entries =C-x 4 a=
** TODO Use ~browse-url-add-buttons~ to make links clickable in more places?
** TODO ~xref-quick-peek~ / ~xref-completing-read~ (~xref-show-xrefs-function~)
** TODO Create macros via checking =C-h l= ('view-lossage') then it can be used together with ~edit-last-kbd-macro~.
** TODO Is it useful to use highlight-regexp?
** TODO solarized colorless config?
** TODO Split theme into several sections
- One theme to set big headers and such things
- One theme to highlight errors
- One theme for the mode-line
** TODO Flymake + Elsa
