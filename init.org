#+TITLE: Emacs Configuration
#+AUTHOR: Terje Larsen
#+PROPERTY: header-args:emacs-lisp :tangle yes :results silent

* Introduction
terlar's Emacs Configuration. It is not very well documented right now, but hopefully I
will have time to write down some more details later.

The rough details:
- theme :: [[https://github.com/11111000000/tao-theme-emacs][tao-theme]] (yang) with [[file:lisp/local-theme.el][some local modifications]]
  - fonts :: [[https://github.com/be5invis/Iosevka][Iosevka Slab]], Noto Sans, Noto Serif
  - semantic highlighting :: [[https://github.com/ankurdave/color-identifiers-mode][color-identifiers-mode]], [[https://github.com/Fanael/rainbow-identifiers][rainbow-identifiers]] (fallback, with wider support)
- menu completion :: [[https://github.com/raxod502/selectrum][selectrum]], [[https://github.com/abo-abo/swiper][ivy]]
- buffer completion :: [[https://github.com/company-mode/company-mode][company-mode]]
- +modal editing (vi) :: [[https://github.com/emacs-evil/evil][evil]]+
- package configuration :: [[https://github.com/jwiegley/use-package][use-package]]
- key definitions :: [[https://github.com/noctuid/general.el][general]]
- code navigation :: [[https://github.com/jacktasia/dumb-jump][dumb-jump]], [[https://github.com/jojojames/smart-jump][smart-jump]], [[https://github.com/iqbalansari/emacs-source-peek][source-peek]], [[https://github.com/vspinu/imenu-anywhere][imenu-anywhere]]
- syntax checker :: flymake
- persistent undo :: via built-in =desktop-save-mode=
- language server integration :: [[https://github.com/joaotavora/eglot][eglot]]

** Screenshots
*** org-mode
#+CAPTION: org-mode
[[file:media/tao-yang/org-mode.png]]

*** markdown-mode
#+CAPTION: markdown-mode
[[file:media/tao-yang/markdown-mode.png]]

*** emacs-lisp-mode
#+CAPTION: emacs-lisp-mode
[[file:media/tao-yang/emacs-lisp-mode.png]]

* The beginning
Every good file starts with a nice header and enable lexical scoping as per the
recommendations of the [[https://github.com/bbatsov/emacs-lisp-style-guide#source-code-layout--organization][The Emacs Lisp Style Guide]].
#+BEGIN_SRC emacs-lisp
;;; init.el --- Emacs Initialization -*- lexical-binding: t; -*-

;; URL: https://github.com/terlar/emacs-config
;; Version: 1.0.0
;; Package-Requires: ((emacs "26.1"))

;;; Commentary:
;; terlar's Emacs Configuration.
#+END_SRC

** Variables
Provide an easy way to toggle debug mode which will set certain variables to produce more
informative output. It can be set either by providing the environment variable =DEBUG= or
start Emacs with =--debug-init=.
#+BEGIN_SRC emacs-lisp
(eval-and-compile
  (defvar init-debug-mode
    (or (getenv "DEBUG") init-file-debug)
    "Debug mode, enable through DEBUG=1 or use --debug-init.")
  (setq debug-on-error (and (not noninteractive) init-debug-mode)))
#+END_SRC

Provide a location where Emacs can store data and cache.
#+BEGIN_SRC emacs-lisp
(eval-and-compile
  (defvar init-data-dir
    (if (getenv "XDG_DATA_HOME")
        (concat (getenv "XDG_DATA_HOME") "/emacs/")
      (expand-file-name "~/.local/share/emacs/"))
    "Directory for data.")

  (defvar init-cache-dir
    (if (getenv "XDG_CACHE_HOME")
        (concat (getenv "XDG_CACHE_HOME") "/emacs/")
      (expand-file-name "~/.cache/emacs/"))
    "Directory for cache."))
#+END_SRC

** Quiet startup
#+BEGIN_SRC emacs-lisp
(setq inhibit-default-init t
      inhibit-startup-screen t
      inhibit-startup-echo-area-message t
      initial-major-mode 'fundamental-mode
      initial-scratch-message nil)
#+END_SRC

** UX
Disable bell (both visual and audible)
#+BEGIN_SRC emacs-lisp
(setq ring-bell-function #'ignore
      visible-bell nil)
#+END_SRC

Use =y= / =n= instead of =yes= / =no=
#+BEGIN_SRC emacs-lisp
(setq confirm-kill-emacs #'y-or-n-p)
(fset #'yes-or-no-p #'y-or-n-p)
#+END_SRC

** Custom file
Put custom defs in a temporary file so it doesn't grow over time.
#+BEGIN_SRC emacs-lisp
(setq custom-file (expand-file-name "custom.el" temporary-file-directory))
#+END_SRC

** Load path
#+BEGIN_SRC emacs-lisp
(eval-and-compile
  (setq load-path
        (append (delete-dups load-path)
                (list (expand-file-name "lisp" user-emacs-directory)
                      (expand-file-name "private" user-emacs-directory)))))
#+END_SRC

** Shell
Set shell to bash as fish is not compatible with all packages using the shell.
#+BEGIN_SRC emacs-lisp
(setq shell-file-name "bash")
#+END_SRC

** Package management
*** use-package
#+BEGIN_SRC emacs-lisp
(eval-when-compile
  (require 'use-package nil t))
(setq use-package-always-defer t)

(if init-debug-mode
    (setq use-package-verbose t
          use-package-expand-minimally nil
          use-package-compute-statistics t)
  (setq use-package-verbose nil
        use-package-expand-minimally t))
#+END_SRC

** Packages
*** no-littering
Help keeping user Emacs directory clean.
#+BEGIN_SRC emacs-lisp
(use-package no-littering
  :demand t
  :custom
  (no-littering-etc-directory init-data-dir)
  (no-littering-var-directory init-cache-dir))
#+END_SRC

*** exec-path-from-shell
#+BEGIN_SRC emacs-lisp
(use-package exec-path-from-shell
  :hook (after-init . exec-path-from-shell-initialize)
  :custom (exec-path-from-shell-check-startup-files nil))
#+END_SRC

*** server
#+BEGIN_SRC emacs-lisp
(use-package server
  :commands (server-running-p)
  :preface
  (defun init-server-ensure-running (frame)
    "Ensure server is running when launching FRAME."
    (with-selected-frame frame
      (unless (server-running-p)
        (server-start))))
  :init
  (add-hook 'after-make-frame-functions #'init-server-ensure-running))
#+END_SRC

*** savehist
Persist history.
#+BEGIN_SRC emacs-lisp
(use-package savehist
  :custom
  (savehist-additional-variables
   '(kill-ring
     search-ring
     regexp-search-ring))
  (savehist-autosave-interval 60)
  (savehist-save-minibuffer-history t)
  :init
  (savehist-mode 1))
#+END_SRC

** Libraries
*** cl-lib
#+BEGIN_SRC emacs-lisp
(require 'cl-lib)
#+END_SRC

*** async
#+BEGIN_SRC emacs-lisp
(use-package async)
#+END_SRC

*** flymake-quickdef
#+BEGIN_SRC emacs-lisp
(use-package flymake-quickdef :demand t)
#+END_SRC

*** posframe
#+BEGIN_SRC emacs-lisp
(use-package posframe
  :custom
  (posframe-mouse-banish nil))
#+END_SRC

** Tangling
Support auto-tangling via =auto-tangle-mode=.
#+BEGIN_SRC emacs-lisp
(use-package auto-tangle
  :commands (auto-tangle-mode))
#+END_SRC

* Base
** Performance
Give up some bidirectional functionality for slightly faster re-display.
#+BEGIN_SRC emacs-lisp
(setq bidi-inhibit-bpa t)
(setq-default bidi-paragraph-direction 'left-to-right)
#+END_SRC

Update UI less frequently
#+BEGIN_SRC emacs-lisp
(setq idle-update-delay 2
      jit-lock-defer-time 0)
#+END_SRC
*** Packages
**** so-long
Improve performance for files with long lines, for example minified code.
#+BEGIN_SRC emacs-lisp
(use-package so-long
  :defer 2
  :config
  (global-so-long-mode 1))
#+END_SRC

**** vlf
Large file support. This can view/edit/search and compare large files.
#+BEGIN_SRC emacs-lisp
(use-package vlf)
#+END_SRC

** Localization
#+BEGIN_SRC emacs-lisp
(setq-default calendar-week-start-day 1)
#+END_SRC

** Terminal
*** Pager
Make less work inside Emacs shells. But disable it as the default pager.
#+BEGIN_SRC emacs-lisp
(setenv "LESS" "--dumb --prompt=s")
(setenv "PAGER" "")
#+END_SRC

** Packages
*** all-the-icons
Support functions for displaying icons. I am trying to use icons where possible.
#+BEGIN_SRC emacs-lisp
(use-package all-the-icons)
#+END_SRC

*** auto-minor-mode
Enable minor modes by buffer name and contents. It provides the =use-package= keyword
=:minor= and =:magic-minor= where you can specify these rules.
#+BEGIN_SRC emacs-lisp
(use-package auto-minor-mode :demand t)
#+END_SRC

*** defrepeater
Support defining repeating commands by repeating the last key.
#+BEGIN_SRC emacs-lisp
(use-package defrepeater
  :commands (defrepeater))
#+END_SRC

*** general
More convenient key definitions. I provides the =use-package= keyword =:general=.
#+BEGIN_SRC emacs-lisp
(use-package general
  :demand t
  :commands (general-define-key))
#+END_SRC

*** hide-lines
#+BEGIN_SRC emacs-lisp
(use-package hide-lines)
#+END_SRC

*** minions
#+BEGIN_SRC emacs-lisp
(use-package minions
  :general
  ([C-S-mouse-1] 'minions-minor-modes-menu))
#+END_SRC

*** quick-peek
Library to display inline popups; used by =source-peek=.
#+BEGIN_SRC emacs-lisp
(use-package quick-peek)
#+END_SRC

*** which-key
Display available keybindings in a popup.
#+BEGIN_SRC emacs-lisp
(use-package which-key
  :defer 1
  :commands
  (which-key-mode
   which-key-setup-side-window-bottom
   which-key-key-order-alpha)
  :custom
  (which-key-sort-order #'which-key-key-order-alpha)
  (which-key-sort-uppercase-first nil)
  (which-key-add-column-padding 1)
  (which-key-min-display-lines 5)
  (which-key-idle-delay 1)
  :config
  (dolist (item '((("<\\([[:alnum:]-]+\\)>" . nil) . ("\\1" . nil))
                  (("\\`\\?\\?\\'" . nil) . ("λ" . nil))
                  (("<up>" . nil) . ("↑" . nil))
                  (("<right>" . nil) . ("→" . nil))
                  (("<down>" . nil) . ("↓" . nil))
                  (("<left>" . nil) . ("←" . nil))
                  (("SPC" . nil) . ("␣" . nil))
                  (("TAB" . nil) . ("↹" . nil))
                  (("RET" . nil) . ("⏎" . nil))
                  (("DEL" . nil) . ("⌫" . nil))
                  (("deletechar" . nil) . ("⌦" . nil))))
    (cl-pushnew item which-key-replacement-alist :test #'equal))

  (which-key-setup-side-window-bottom)

  (which-key-mode 1))
#+END_SRC

** Functions
Prevent forms from producing output or other noise.
#+BEGIN_SRC emacs-lisp
(defmacro init-quiet! (&rest forms)
  "Run FORMS without making any noise."
  `(if init-debug-mode
       (progn ,@forms)
     (let ((message-log-max nil))
       (with-temp-message (or (current-message) "") ,@forms))))

(defun init-quiet-function-advice (orig-fn &rest args)
  "Advice used to make a function quiet.
Call ORIG-FN with ARGS and suppress the output.

Example:
  (advice-add #'orig-fun :around #'init-quiet-function-advice)"
  (init-quiet! (apply orig-fn args)))
#+END_SRC

Run forms when graphical frame is created.
#+BEGIN_SRC emacs-lisp
(defmacro init-eval-after-make-graphic-frame (hook-id &rest forms)
  "Run HOOK-ID hook with FORMS after making a frame on a graphic display.
Add a hook to `after-make-frame-functions' with form wrapped in a
`display-graphic-p' condition.

Also add a hook to `after-init-hook' with a form wrapped in a
`display-graphic-p' condition in order to work with the initial
frame when not running in server mode."
  (let ((hook-name (intern
                    (concat
                     "init-eval-after-make-graphic-frame--"
                     hook-id
                     "-hook"))))
    `(progn
       (cl-defun ,hook-name (&optional (frame (selected-frame)))
         (with-selected-frame frame
           (when (display-graphic-p)
             ,@forms)))
       (add-hook 'after-init-hook #',hook-name)
       (add-hook 'after-make-frame-functions #',hook-name))))
#+END_SRC

*** Display
#+BEGIN_SRC emacs-lisp
(defun init-display-ctrl-M-as-newline ()
  "Display `^M' as newline."
  (interactive)
  (setq buffer-display-table (make-display-table))
  (aset buffer-display-table ?\^M [?\n]))
#+END_SRC

*** Process
#+BEGIN_SRC emacs-lisp
(defun send-buffer-to-ssh ()
  "Send the whole buffer to the *ssh* process."
  (interactive)
  (process-send-region "*ssh*" (point-min) (point-max)))

(defun send-to-ssh ()
  "Send selected region or current line to the *ssh* process."
  (interactive)
  (let ((procbuf "*ssh*"))
    (if (use-region-p)
        (process-send-region procbuf (region-beginning) (region-end))
      (process-send-string procbuf (thing-at-point 'line t)))))
#+END_SRC

*** Window
Dedicated window:
#+BEGIN_SRC emacs-lisp
(defun toggle-dedicated-window ()
  "Toggle selected window as dedicated window."
  (interactive)
  (set-window-dedicated-p (selected-window)
                          (not (window-dedicated-p (selected-window)))))
#+END_SRC

Fringe control:
#+BEGIN_SRC emacs-lisp
(defun no-fringes ()
  "Remove all fringes."
  (interactive)
  (set-window-fringes (selected-window) 0 0 nil))

(defun restore-fringes ()
  "Restore fringes."
  (interactive)
  (set-window-fringes (selected-window) 8 8 t))
#+END_SRC

* Keybindings
I am trying to reduce the amount of keybindings, therefore I present a table of default
keybindings in case I would forget them.

** Aliases
| Keybinding | Alternative |
|------------+-------------|
| =M-=         | =C-[=         |
| =TAB=        | =C-i=         |
| =RET=        | =C-j=         |

** Commands
| Keybinding      | Function                        | Description                                                                      |
|-----------------+---------------------------------+----------------------------------------------------------------------------------|
| =C-o=             | =open-line=                       | Open line below                                                                  |
| =M-SPC=           | =just-one-space=                  | Ensures just one space                                                           |
| =M-\=             | =delete-horizontal-space=         | Delete all space                                                                 |
| =M-^=             | =delete-indentation=              | Join current line with previous line                                             |
| =M-z=             | =zap-to-char=                     | Delete until character                                                           |
| =C-S-backspace=   | =kill-whole-line=                 | Kill entire lines, can be used to move several lines at once                     |
| =M-/=             | =dabbrev-expand=                  | Abbreviation completion                                                          |
| =M-tab= / =C-[ C-i= | =completion-at-point= / =pcomplete= | More context aware completion                                                    |
| =C-w=             | =kill-region=                     | Cut                                                                              |
| =M-w=             | =kill-ring-save=                  | Copy                                                                             |
| =C-y=             | =yank=                            | Paste                                                                            |
| =M-y=             | =yank-next=                       | Paste (next item)                                                                |
| =C-x SPC=         | =rectangle-mark-mode=             | Rectangular selection                                                            |
| =C-x r t=         | =string-rectangle=                | Insert string in beginning of rectangular selection (=C-t= in =rectangle-mark-mode=) |
| =C-M-f=           | =forward-sexp=                    | Move forward inside a balanced expression                                        |
| =C-M-b=           | =backward-sexp=                   | Move backward inside a balanced expression                                       |
| =C-M-n=           | =forward-list=                    | Move forward across one balanced group of parenthesis                            |
| =C-M-p=           | =backward-list=                   | Move backward across one balanced group of parenthesis                           |
| =M-m=             | =back-to-indentation=             | Move to the first non-whitespace character                                       |
| =M-e=             | =forward-sentence=                | End of sentence                                                                  |
| =M-a=             | =backward-sentence=               | Start of sentence                                                                |
| =C-M-d=           | =down-list=                       | Move forward down one level of parenthesis                                       |
| =C-M-u=           | =backward-up-list=                | Move backward out of one level of parenthesis                                    |

** Ivy
| Keybinding | Function           | Description                                              |
|------------+--------------------+----------------------------------------------------------|
| =C-M-j=      | =ivy-immediate-done= | Accept input without selecting, (e.g. for new file name) |

** Gnus
| Keybinding | Function                              | Description                                                   |
|------------+---------------------------------------+---------------------------------------------------------------|
| =L=          | =gnus-group-list-all-groups=            | List all groups (works together with prefix to provide level) |
| =RET=        | =gnus-topic-select-group=               | List group mails (works together with prefix to see all)      |
| =g=          | =gnus-group-get-new-news=               | Refresh groups list                                           |
| =G G=        | =gnus-group-make-nnir-group=            | Search mails at server side                                   |
| =#=          | =gnus-group-mark-group=                 | Mark                                                          |
| =M-#=        | =gnus-group-unmark-group=               | Un-mark                                                       |
| =R=          | =gnus-summary-reply-with-original=      | Reply w/ quoted text                                          |
| =r=          | =gnus-summary-reply=                    | Reploy w/o quoted text                                        |
| =S W=        | =gnus-summary-wide-reply-with-original= | Reply all w/ quoted text                                      |
| =S w=        | =gnus-summary-wide-reply=               | Reply all w/o quoted text                                     |
| =m= / =C-x m=  | =gnus-new-mail=                         | Compose new mail                                              |
| =S D e=      | =gnus-summary-resend-message-edit=      | Re-send a mail in Draft folder                                |
| =C-c C-a=    | =mml-attach-file=                       | Attach a file                                                 |
| =o=          | =gnus-mime-save-part=                   | Save attachment                                               |
| =C-c C-f=    | =gnus-summary-mail-forward=             | Forward mail                                                  |
| =c=          | =gnus-group-catchup-current=            | Mark mails as read                                            |

** Leader keys
#+BEGIN_SRC emacs-lisp
(defvar init-leader-key "C-,"
  "The key used for most custom operations.")
(defvar init-local-leader-key "C-."
  "The key used for major mode operations.")
(defvar init-evil-normal-state-leader-key "SPC"
  "The key used for most custom operations in `evil-normal-state'.")
#+END_SRC

** Prefixes
#+BEGIN_SRC emacs-lisp
(defvar init-launch-prefix "C-c l"
  "Key prefix for commands related to launching.")

(defvar init-toggle-prefix "C-x t"
  "Key prefix for commands related to toggling.")
(defvar init-window-prefix "C-'"
  "Key prefix used for commands related to window operations.")

(defvar init-nav-prefix "M-g"
  "Key prefix used for commands related to navigation.")
(defvar init-search-prefix "M-s"
  "Key prefix used for commands related to search.")

(defvar init-next-prefix "M-]"
  "Key prefix used for commands doing a next operation.")
(defvar init-prev-prefix "M-["
  "Key prefix used for commands doing a previous operation.")
#+END_SRC

** Global
#+BEGIN_SRC emacs-lisp
(general-define-key
 :keymaps 'global
 ;; Editing
 "C-z" 'zap-up-to-char
 ;; Files
 "C-c o" 'ff-find-other-file
 "C-c O" 'ff-test-find-other-file
 ;; Terminal
 "C-!" 'eshell
 "C-M-!" '(lambda () (interactive) (term "fish"))
 ;; Window
 "C-`" 'window-toggle-side-windows)
#+END_SRC

** Navigation
#+BEGIN_SRC emacs-lisp
(general-define-key
 :keymaps 'global
 :prefix init-nav-prefix
 "u" 'browse-url)
#+END_SRC

** Window
#+BEGIN_SRC emacs-lisp
(general-define-key
 :keymaps 'global
 :prefix init-window-prefix
 init-window-prefix 'window-toggle-side-windows
 "d" 'toggle-dedicated-window
 "m" 'maximize-window)
#+END_SRC

** Next
#+BEGIN_SRC emacs-lisp
(general-define-key
 :prefix init-next-prefix
 ""  '(:ignore t :wk "next...")
 "]" `(,(defrepeater #'text-scale-increase)      :wk "Text size")
 "b" `(,(defrepeater #'next-buffer)              :wk "Buffer")
 "c" `(,(defrepeater #'smerge-next)              :wk "Conflict")
 "d" `(,(defrepeater #'diff-hl-next-hunk)        :wk "Diff Hunk")
 "e" `(,(defrepeater #'next-error)               :wk "Error")
 "s" `(,(defrepeater #'flyspell-goto-next-error) :wk "Spell error")
 "t" `(,(defrepeater #'hl-todo-next)             :wk "Todo"))
#+END_SRC

** Previous
#+BEGIN_SRC emacs-lisp
(general-define-key
 :prefix init-prev-prefix
 ""  '(:ignore t :wk "previous...")
 "[" `(,(defrepeater #'text-scale-decrease)    :wk "Text size")
 "b" `(,(defrepeater #'previous-buffer)        :wk "Buffer")
 "c" `(,(defrepeater #'smerge-prev)            :wk "Conflict")
 "d" `(,(defrepeater #'diff-hl-previous-hunk)  :wk "Diff Hunk")
 "e" `(,(defrepeater #'previous-error)         :wk "Error")
 "t" `(,(defrepeater #'hl-todo-previous)       :wk "Todo"))
#+END_SRC

** Toggle
#+BEGIN_SRC emacs-lisp
(general-define-key
 :prefix init-toggle-prefix
 "c" '(highlight-changes-mode           :wk "Changes")
 "d" '(toggle-debug-on-error            :wk "Debug on error")
 "f" '(hs-minor-mode                    :wk "Code folding")
 "g" '(glasses-mode                     :wk "Readable camelCase")
 "h" '(hl-line-mode                     :wk "Line highlight")
 "l" '(global-display-line-numbers-mode :wk "Line numbers")
 "L" '(so-long-mode                     :wk "Long lines")
 "s" '(subword-mode                     :wk "Sub-word")
 "t" '(toggle-truncate-lines            :wk "Truncate lines")
 "v" '(variable-pitch-mode              :wk "Variable-pitch")
 "w" '(whitespace-mode                  :wk "White-space")
 "x" '(flymake-mode                     :wk "Syntax checker"))
#+END_SRC

** Launch
#+BEGIN_SRC emacs-lisp
(general-define-key
 :prefix init-launch-prefix
 "m" 'gnus
 "p" 'list-processes
 "x" 'regexp-builder
 "w" 'eww)
#+END_SRC

* Help
#+BEGIN_SRC emacs-lisp
(general-define-key
 :keymaps 'help-map
 "B" 'find-library
 "u" 'describe-face
 "U" 'list-faces-display
 "'" 'describe-char)
#+END_SRC

* Appearance
** Typography
*** Size
#+BEGIN_SRC emacs-lisp
(defvar init-line-spacing 0.25
  "Spacing between lines.")

(defvar init-default-font-height 120
  "Default font height.")
#+END_SRC

*** Face
#+BEGIN_SRC emacs-lisp
(defvar init-fixed-pitch-font "Iosevka Slab"
  "Font used for fixed-pitch faces.")

(defvar init-variable-pitch-font "Noto Sans"
  "Font used for variable-pitch faces.")

(defvar init-serif-font "Noto Serif"
  "Font used for serif faces.")

(defvar init-unicode-font "Noto Sans Mono"
  "Fallback font used for unicode glyphs.")

(defvar init-emoji-font "Noto Emoji"
  "Font used for symbol/emoji faces.")

(init-eval-after-make-graphic-frame
 "setup-emoji-font"
 (set-fontset-font "fontset-default" 'symbol
                   (font-spec :family init-emoji-font) nil 'prepend))
#+END_SRC

*** Line length
#+BEGIN_SRC emacs-lisp
(setq-default fill-column 90)
#+END_SRC

*** Underline
Underline line at descent position, not baseline position.
#+BEGIN_SRC emacs-lisp
(setq x-underline-at-descent-line t)
#+END_SRC

** Theme
Use a bar cursor by default.
#+begin_src emacs-lisp :tangle yes
(setq-default cursor-type 'bar)
#+end_src

*** Defaults
#+BEGIN_SRC emacs-lisp
(defvar init-default-light-theme 'tao-yang
  "Default light theme.")
(defvar init-default-dark-theme 'tao-yin
  "Default dark theme.")
#+END_SRC

*** Packages
#+BEGIN_SRC emacs-lisp
(use-package tao-theme
  :demand t
  :custom
  (tao-theme-use-sepia t)
  (tao-theme-use-boxes nil))
#+END_SRC

*** Local overrides
No theme is perfect, also this is a good place to put my own experiments.
#+BEGIN_SRC emacs-lisp
(use-package local-theme
  :demand t
  :custom
  (local-theme-default-font-height init-default-font-height)
  (local-theme-line-spacing init-line-spacing)
  (local-theme-fixed-pitch-font init-fixed-pitch-font)
  (local-theme-variable-pitch-font init-variable-pitch-font)
  (local-theme-serif-font init-serif-font))

(defvar init-after-load-theme-hook nil
  "Hook run after a theme is loaded using `load-theme'.")
(defun init-load-theme-run-after-load-theme-hooks (&rest _)
  "Run `init-after-load-theme-hook'."
  (run-hooks 'init-after-load-theme-hook))
(advice-add 'load-theme :after #'init-load-theme-run-after-load-theme-hooks)

(defun init-local-theme-ensure ()
  "Ensure `local-theme' is loaded."
  (unless (member 'local custom-enabled-themes)
    (load-theme 'local t)))
(setq init-after-load-theme-hook '(init-local-theme-ensure))

(init-eval-after-make-graphic-frame
 "load-local-theme"
 (require 'local-theme)
 (load-theme 'local t))
#+END_SRC

*** Enable theme
#+BEGIN_SRC emacs-lisp
(load-theme init-default-light-theme t)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun toggle-default-theme ()
  "Toggle dark/light theme.
Defined via `init-default-dark-theme' and `init-default-light-theme'"
  (interactive)
  (let ((theme (if (member init-default-light-theme custom-enabled-themes)
                   init-default-dark-theme
                 init-default-light-theme)))
    (mapc #'disable-theme custom-enabled-themes)
    (load-theme theme t)))
#+END_SRC

*** Echo area
Adjust the font face used for the echo area.
#+BEGIN_SRC emacs-lisp
(dolist (buffer-name '(" *Echo Area 0*"
                       " *Echo Area 1*"))
  (with-current-buffer (get-buffer-create buffer-name)
    (setq-local face-remapping-alist
                '((default (:height 0.9) variable-pitch)))))
#+END_SRC

** Layout
*** Frame
See [[info:elisp#Frame%20Layout][Frame Layout]] documentation for details and terminology.
- Add some padding around the whole window (=internal-border-width=) to provide some air.
- Remove GUI elements.
- Maximize the window; A maximized window ensures macOS won't waste extra space all-though
  it is technically not maximized.
- Make the title-bar transparent on macOS.
#+BEGIN_SRC emacs-lisp
(setq default-frame-alist
      '((internal-border-width . 16)
        (vertical-scroll-bars . nil)
        (menu-bar-lines . 0)
        (tool-bar-lines . 0)))

(when (eq system-type 'darwin)
  (setq frame-title-format nil)
  (dolist (filter '((ns-transparent-titlebar . t)
                    (ns-appearance . unbound)))
    (cl-pushnew filter default-frame-alist :test #'equal)))
#+END_SRC

*** Fringe
Setup fringes on both sides and display an indicator for buffer boundaries on the right
side. Display fringes outside margins to have the [[Padding][padding]] on the inside.
#+BEGIN_SRC emacs-lisp
(setq-default fringes-outside-margins t
              left-fringe-width 8
              right-fringe-width 8
              indicate-buffer-boundaries 'right)
#+END_SRC

*** Padding
Add margins inside windows to make text feel less crowded. Padding around the frame is
configured via the =internal-border-width= in the [[Frame][Frame]] section.
#+BEGIN_SRC emacs-lisp
(setq-default left-margin-width 1
              right-margin-width 1)
#+END_SRC

*** Borders
Add window dividers, mainly to add a border below the mode line.
#+BEGIN_SRC emacs-lisp
(setq window-divider-default-places t
      window-divider-default-bottom-width 1
      window-divider-default-right-width 1)

(init-eval-after-make-graphic-frame
 "setup-window-divider"
 (window-divider-mode 1))
#+END_SRC

** Mode line
I try to retain functionality from the original mode line as much as possible, but I also
want to simplify it slightly and separate into two parts; left side and right side mode
line. There is a helper function in order to fill up the space needed to make the mode
line appear on the right side. Also the coding system related information will be hidden
if using utf-8-unix.

Define a variable to conveniently access only the major mode part of =mode-line-modes=.
#+BEGIN_SRC emacs-lisp
(defvar mode-line-major-mode
  `(:propertize ("" mode-name)
                help-echo "Major mode\n\
mouse-1: Display major mode menu\n\
mouse-2: Show help for major mode\n\
mouse-3: Toggle minor modes"
                mouse-face mode-line-highlight
                local-map ,mode-line-major-mode-keymap))
#+END_SRC

Configure the order and components of the mode line.
#+BEGIN_SRC emacs-lisp
(setq-default mode-line-format
              '("%e" mode-line-front-space
                mode-line-misc-info
                (vc-mode vc-mode)
                "  "
                mode-line-modified
                mode-line-remote
                mode-line-buffer-identification
                mode-line-position
                (:eval
                 (mode-line-right))
                mode-line-end-spaces))
#+END_SRC

*** Right alignment
Setup the right aligned mode line and helper functions to display it.
#+BEGIN_SRC emacs-lisp
(defvar mode-line-right-format nil
  "The mode line to display on the right side.")

(defun mode-line-right ()
  "Render the `mode-line-right-format'."
  (let* ((formatted-line (format-mode-line mode-line-right-format))
         (height (face-attribute 'mode-line :height))
         (scale (if (floatp height) height 1.0)))
    (list
     (propertize
      " " 'display `((space :align-to (- (+ right right-fringe right-margin)
                                         ,(* (string-width formatted-line) scale)))))
     formatted-line)))
#+END_SRC

Move default components to the right side of the mode line.
#+BEGIN_SRC emacs-lisp
(setq mode-line-right-format
      (list '(:eval mode-line-mule-info)
            "  "
            mode-line-major-mode))
#+END_SRC

*** Position
Add position information including column and line number but skip the percentage.
#+BEGIN_SRC emacs-lisp
(setq column-number-indicator-zero-based nil
      mode-line-percent-position nil)
(column-number-mode 1)
(line-number-mode 1)
#+END_SRC

*** Coding system
To reduce unnecessary information coding system will not be shown by default if the file
is UTF-8 with UNIX end-of-line.
- Only display "end of line"-mnemonic when not UNIX end-of-line.
- Only display coding system when not UTF-8.
- Other cases displays either with warning/error face in order to draw attention.
#+BEGIN_SRC emacs-lisp
(setq eol-mnemonic-unix ""
      eol-mnemonic-dos (propertize "[CR+LF]" 'face 'warning)
      eol-mnemonic-mac (propertize "[CR]" 'face 'warning)
      eol-mnemonic-undecided (propertize "[?]" 'face 'error))

(let ((coding (nthcdr 2 mode-line-mule-info)))
  (setcar coding '(:eval (if (string-equal "U" (format-mode-line "%z"))
                             ""
                           (propertize "[%z]" 'face 'warning))))
  coding)
#+END_SRC

*** Indentation
Display information about the current indentation settings.
#+BEGIN_SRC emacs-lisp
(use-package indent-info
  :defer 1
  :commands
  (global-indent-info-mode)
  :custom
  (indent-info-display-change-message-p nil)
  (indent-info-insert-target 'mode-line-mule-info)
  (indent-info-space-format "Spaces: %s")
  (indent-info-tab-format "Tab Size: %s")
  (indent-info-sync-from-editorconfig t)
  (indent-info-sync-to-editorconfig t)
  :config
  (global-indent-info-mode 1))
#+END_SRC

*** Hide mode line
Support hiding the mode line, this can be useful for different modes displaying documents
or presentation.
#+BEGIN_SRC emacs-lisp
(use-package hide-mode-line
  :commands
  (hide-mode-line-mode
   turn-on-hide-mode-line-mode
   turn-off-hide-mode-line-mode))
#+END_SRC

*** Icons
**** Modified
#+BEGIN_SRC emacs-lisp
(defun mode-line-modified-icons ()
  "Icon representation of `mode-line-modified'."
  (cond (buffer-read-only
         (concat (all-the-icons-octicon "lock" :v-adjust -0.05) " "))
        ((buffer-modified-p)
         (concat (all-the-icons-faicon "floppy-o" :v-adjust -0.05) " "))
        ((and buffer-file-name
              (not (file-exists-p buffer-file-name)))
         (concat (all-the-icons-octicon "circle-slash" :v-adjust -0.05) " "))))

(with-eval-after-load 'all-the-icons
  (setq-default mode-line-modified '((:eval (mode-line-modified-icons)))))
#+END_SRC

**** Remote
#+BEGIN_SRC emacs-lisp
(defun mode-line-remote-icons ()
  "Icon representation of `mode-line-remote'."
  (when (and buffer-file-name
             (file-remote-p buffer-file-name))
    (concat (all-the-icons-octicon "radio-tower" :v-adjust -0.02) " ")))

(with-eval-after-load 'all-the-icons
  (setq-default mode-line-remote   '((:eval (mode-line-remote-icons)))))
#+END_SRC

**** VCS
Shorten long Git branch names as well as replace Git prefix with a nice icon.
#+BEGIN_SRC emacs-lisp
(defun +shorten-vc-mode-line (string)
  "Shorten `version-control' STRING in mode-line and add icon."
  (cond
   ((string-prefix-p "Git" string)
    (concat (all-the-icons-octicon "git-branch" :v-adjust -0.05)
            " "
            (if (> (length string) 30)
                (concat (substring-no-properties string 4 30) "…")
              (substring-no-properties string 4))))
   (t
    string)))
(advice-add 'vc-git-mode-line-string :filter-return #'+shorten-vc-mode-line)
#+END_SRC

* Display
** Window
*** Favor horizontal splits
#+BEGIN_SRC emacs-lisp
(setq split-width-threshold nil)
#+END_SRC

*** Manage layouts
Undo/redo between window layouts.
#+BEGIN_SRC emacs-lisp
(use-package winner
  :hook
  (window-setup . winner-mode)
  :custom
  (winner-dont-bind-my-keys t)
  :config
  (general-define-key
   :prefix init-next-prefix
   init-next-prefix (defrepeater #'winner-redo))
  (general-define-key
   :prefix init-prev-prefix
   init-prev-prefix (defrepeater #'winner-undo)))
#+END_SRC

Transpose window arrangement.
#+BEGIN_SRC emacs-lisp
(use-package transpose-frame
  :general
  (:prefix
   init-window-prefix
   "t" 'transpose-frame
   "f" 'flip-frame
   "F" 'flop-frame))
#+END_SRC

*** Navigation
#+BEGIN_SRC emacs-lisp
(use-package frame
  :general
  ("M-n" 'next-window-any-frame
   "M-p" 'previous-window-any-frame))
#+END_SRC

*** Zoom
Zoom a window to display as a single window temporarily.
#+BEGIN_SRC emacs-lisp
(use-package zoom-window
  :general
  (:prefix
   init-window-prefix
   "z" 'zoom-window-zoom))
#+END_SRC

** Buffer
*** Popups
Always display pop up buffers at the bottom and regard all star buffers as such buffers.
#+BEGIN_SRC emacs-lisp
(dolist (rule `((,(rx bos "*" (one-or-more anything) "*" (optional "<" (one-or-more anything) ">") eos)
                 (display-buffer-reuse-window
                  display-buffer-in-side-window)
                 (reusable-frames . visible)
                 (side . bottom)
                 (window-height . 0.4))
                ("^*Warn about privacy*" display-buffer-pop-up-window)))
  (cl-pushnew rule display-buffer-alist :test #'equal))
#+END_SRC

*** Hide async shell command buffers
#+BEGIN_SRC emacs-lisp
(cl-pushnew '("^*Async Shell Command*" . (display-buffer-no-window))
            display-buffer-alist
            :test #'equal)
#+END_SRC

*** Visual Fill Column
Wrap lines according to =fill-column= in =visual-line-mode=.
#+BEGIN_SRC emacs-lisp
(use-package visual-fill-column
  :custom
  (visual-fill-column-center-text t))
#+END_SRC

* Editing
** Indentation
Convert between tabs and spaces (only tabify initial white-space)
#+BEGIN_SRC emacs-lisp
(setq-default tabify-regexp "^\t* [ \t]+")
#+END_SRC

** Text flow
Wrap at words and don't require double spaces to end a sentence.
#+BEGIN_SRC emacs-lisp
(setq-default word-wrap t)
#+END_SRC

** Kill-ring
Save clipboard contents into kill-ring before replacing them
#+BEGIN_SRC emacs-lisp
(setq save-interprogram-paste-before-kill t)
#+END_SRC

** Packages
*** avy
Jump to things.
#+BEGIN_SRC emacs-lisp
(use-package avy
  :custom
  (avy-all-windows nil)
  :general
  (:prefix
   init-search-prefix
   "SPC" 'avy-goto-word-or-subword-1
   "s" 'avy-goto-char
   "l" 'avy-goto-line
   "m" 'avy-pop-mark))
#+END_SRC

*** cycle-quotes
#+BEGIN_SRC emacs-lisp
(use-package cycle-quotes
  :commands
  (cycle-quotes)
  :preface
  (defrepeater #'cycle-quotes)
  :general
  ("C-x C-'" 'cycle-quotes-repeat))
#+END_SRC

*** goto-addr
Buttonize URLs and e-mail addresses in the current buffer.
#+BEGIN_SRC emacs-lisp
(use-package goto-addr
  :hook
  (text-mode . goto-address-mode)
  (prog-mode . goto-address-prog-mode))
#+END_SRC

*** parrot
Cycle through words, symbols and patterns.
#+BEGIN_SRC emacs-lisp
(use-package parrot
  :commands
  (parrot-rotate-next-word-at-point
   parrot-rotate-prev-word-at-point)
  :preface
  (defrepeater #'parrot-rotate-next-word-at-point)
  (defrepeater #'parrot-rotate-prev-word-at-point)
  :general
  (:prefix
   init-next-prefix
   "r" '(parrot-rotate-prev-word-at-point-repeat :wk "Rotate word"))
  (:prefix
   init-prev-prefix
   "r" '(parrot-rotate-prev-word-at-point-repeat :wk "Rotate word"))
  :config
  (dolist (entry '((:rot ("assert" "refute"))))
    (cl-pushnew entry parrot-rotate-dict :test #'equal)))
#+END_SRC

*** string-inflection-cycle
#+BEGIN_SRC emacs-lisp
(use-package string-inflection
  :general
  ("M-_" 'string-inflection-all-cycle))
#+END_SRC

*** smartparens
Auto-insert matching parenthesis and highlight matching parenthesis.
#+BEGIN_SRC emacs-lisp
(use-package smartparens
  :hook
  (eval-expression-minibuffer-setup . smartparens-strict-mode)
  :commands
  (smartparens-global-strict-mode
   show-smartparens-global-mode)
  :general
  (:prefix
   init-toggle-prefix
   "p" 'smartparens-strict-mode)
  (:keymaps
   'smartparens-mode-map
   "M-'" 'sp-change-inner
   "M-D" 'sp-unwrap-sexp
   "M-R" 'sp-rewrap-sexp
   "M-W" 'sp-wrap-round)
  :preface
  (defun +smartparens-no-autoinsert-pair-advice (orig-fn &rest args)
    "Disable command smartparens autoinsert when running ORIG-FN with ARGS."
    (let ((sp-autoinsert-pair nil))
      (apply orig-fn args)))
  :init
  (smartparens-global-strict-mode 1)
  (show-smartparens-global-mode 1)
  :config
  (require 'smartparens-config)

  (sp-local-pair 'minibuffer-inactive-mode "'" nil :actions nil)

  (sp-with-modes 'org-mode
    (sp-local-pair "*" "*"
                   :actions '(insert wrap)
                   :unless '(sp-point-after-word-p sp-point-at-bol-p)
                   :wrap "C-*" :skip-match 'sp--org-skip-asterisk)
    (sp-local-pair "_" "_" :unless '(sp-point-after-word-p)
                   :wrap "C-_")
    (sp-local-pair "/" "/" :unless '(sp-point-after-word-p)
                   :post-handlers '(("[d1]" "SPC")))
    (sp-local-pair "~" "~" :unless '(sp-point-after-word-p)
                   :post-handlers '(("[d1]" "SPC")))
    (sp-local-pair "=" "=" :unless '(sp-point-after-word-p)
                   :post-handlers '(("[d1]" "SPC")))
    (sp-local-pair "«" "»"))

  (sp-with-modes 'nix-mode
    (sp-local-pair "'" "'"
                   :unless '(sp-in-comment-p
                             sp-in-string-quotes-p))
    (sp-local-pair "\"" "\"")
    (sp-local-pair "''" "''"
                   :unless '(sp-in-comment-p
                             sp-in-string-quotes-p)))

  (advice-add #'hippie-expand :around #'+smartparens-no-autoinsert-pair-advice))
#+END_SRC

*** visual-regexp
Visually highlight regular expression searches as you type. Also supports replace.
#+BEGIN_SRC emacs-lisp
(use-package visual-regexp
  :general
  ("M-s r" 'vr/query-replace
   "M-s R" 'vr/replace))
#+END_SRC

*** whitespace
Display whitespace
#+BEGIN_SRC emacs-lisp
(use-package whitespace
  :custom
  (whitespace-line-column fill-column)
  (whitespace-style
   '(face tabs tab-mark spaces space-mark trailing lines-tail))
  (whitespace-display-mappings
   '((tab-mark ?\t [?› ?\t])
     (newline-mark 10 [?¬ 10])
     (space-mark 32 [183] [46]))))
#+END_SRC

*** whole-line-or-region
Cut/copy (=C-w= / =M-w=) the current line if no region is active.
#+BEGIN_SRC emacs-lisp
(use-package whole-line-or-region
  :commands
  (whole-line-or-region-global-mode)
  :init
  (whole-line-or-region-global-mode 1))
#+END_SRC

*** yasnippet
#+BEGIN_SRC emacs-lisp
(use-package yasnippet
  :defer 1
  :commands
  (yas--templates-for-key-at-point)
  :custom
  (yas-also-auto-indent-first-line t)
  (yas-snippet-dirs (list (expand-file-name "snippets" user-emacs-directory)))
  ;; Nested snippets
  (yas-triggers-in-field t)
  (yas-wrap-around-region t)
  :general
  (:keymaps
   'yas-minor-mode-map
   [tab] 'nil
   "TAB" 'nil
   "M-o" 'yas-insert-snippet)
  :init
  (setq yas-verbosity 0)
  :config
  (yas-global-mode 1))

(use-package yasnippet-snippets
  :hook
  (yas-minor-mode . yasnippet-snippets-initialize))
#+END_SRC

*** yatemplate
#+BEGIN_SRC emacs-lisp
(use-package autoinsert
  :hook
  (after-init . auto-insert-mode)
  :custom
  (auto-insert-query nil))

(use-package yatemplate
  :hook
  (auto-insert-mode . yatemplate-fill-alist))
#+END_SRC

** Appearance
*** Page breaks
Display page breaks as a horizontal line.
#+BEGIN_SRC emacs-lisp
(use-package page-break-lines
  :defer 1
  :config
  (global-page-break-lines-mode 1))
#+END_SRC

*** Line highlight
Disabled by default. When enabled, only highlight in the selected window.
#+BEGIN_SRC emacs-lisp
(use-package hl-line
  :custom
  (hl-line-sticky-flag nil)
  (global-hl-line-sticky-flag nil))
#+END_SRC

* Buffers
Prevent generation of useless lock and backup files.
#+BEGIN_SRC emacs-lisp
(setq create-lockfiles nil
      make-backup-files nil)
#+END_SRC

Don't require confirmation when opening a new buffer.
#+BEGIN_SRC emacs-lisp
(setq confirm-nonexistent-file-or-buffer t)
#+END_SRC

Remove visual indicators from non-selected windows
#+BEGIN_SRC emacs-lisp
(setq highlight-nonselected-windows nil)
(setq-default cursor-in-non-selected-windows nil)
#+END_SRC

** Auto save
#+BEGIN_SRC emacs-lisp
(auto-save-visited-mode 1)
(setq save-abbrevs 'silently)
#+END_SRC

** Auto executable scripts
#+BEGIN_SRC emacs-lisp
(add-hook 'after-save-hook #'executable-make-buffer-file-executable-if-script-p)
#+END_SRC

** Minibuffer
Enable recursive minibuffers and keep the point out of the minibuffer.
#+BEGIN_SRC emacs-lisp
(setq enable-recursive-minibuffers t
      minibuffer-prompt-properties
      '(read-only t point-entered minibuffer-avoid-prompt face minibuffer-prompt))
#+END_SRC

Give some more room to the minbuffer.
#+BEGIN_SRC emacs-lisp
(setq max-mini-window-height 0.3
      resize-mini-windows 'grow-only)
#+END_SRC

*** No fringes
Don't show fringes in the minibuffer.
#+BEGIN_SRC emacs-lisp
(defun init-disable-minibuffer-window-fringes (&optional frame)
  "Disable the window fringes for minibuffer window in FRAME."
  (let ((target (if frame frame (selected-frame))))
    (with-selected-frame target
      (set-window-fringes (minibuffer-window) 0 0 nil))))
(add-hook 'after-make-frame-functions #'init-disable-minibuffer-window-fringes)
(add-hook 'minibuffer-setup-hook #'init-disable-minibuffer-window-fringes)
#+END_SRC

*** History
Track minibuffer history
#+BEGIN_SRC emacs-lisp
(setq history-delete-duplicates t
      history-length 500)
#+END_SRC

*** Miniedit
Edit minibuffer in a new temporary buffer by pressing =C-c '=.
#+BEGIN_SRC emacs-lisp
(use-package miniedit
  :general
  (:keymaps
   '(minibuffer-local-map
     minibuffer-local-ns-map
     minibuffer-local-completion-map
     minibuffer-local-must-match-map)
   "C-c '" 'miniedit))
#+END_SRC

** Scrolling
More procedural scrolling.
#+BEGIN_SRC emacs-lisp
(setq auto-window-vscroll nil
      hscroll-margin 5
      hscroll-step 5
      scroll-margin 0
      scroll-preserve-screen-position t)

(setq-default scroll-down-aggressively 0.01
              scroll-up-aggressively 0.01)
#+END_SRC

** Packages
*** autorevert
Revert buffers when underlying files change.
#+BEGIN_SRC emacs-lisp
(use-package autorevert
  :custom
  (auto-revert-verbose nil))
#+END_SRC

*** default-text-scale
#+BEGIN_SRC emacs-lisp
(use-package default-text-scale
  :general
  ("C-M-=" 'default-text-scale-increase)
  ("C-M--" 'default-text-scale-decrease)
  ("C-M-0" 'default-text-scale-reset))
#+END_SRC

*** eldoc
#+BEGIN_SRC emacs-lisp
(use-package eldoc
  :config
  (global-eldoc-mode 1))
#+END_SRC

*** rainbow-mode
Display colors inline.
#+BEGIN_SRC emacs-lisp
(use-package rainbow-mode
  :minor
  "-theme\\.el\\'"
  :hook
  help-mode)
#+END_SRC

*** readable
#+BEGIN_SRC emacs-lisp
(use-package readable
  :hook
  ((eww-mode
    markdown-mode
    nov-mode
    org-mode
    outline-mode
    rst-mode) . readable-mode))
#+END_SRC

*** relative-buffers
#+BEGIN_SRC emacs-lisp
(use-package relative-buffers
  :hook
  (after-init . global-relative-buffers-mode)
  :custom
  (relative-buffers-project-prefix t))
#+END_SRC

*** wgrep-ag
Writeable grep buffer with ability to apply the changes to all the files.
#+BEGIN_SRC emacs-lisp
(use-package wgrep-ag
  :custom
  (wgrep-auto-save-buffer t))
#+END_SRC

* Navigation
Allow repeated mark popping. This behavior is similar to Vim's =C-o=. With this
configuration you can press =C-u= and continuously =C-SPC= to jump to previous entries in the
mark ring.
#+BEGIN_SRC emacs-lisp
(setq set-mark-command-repeat-pop t)
#+END_SRC

** Dired
#+BEGIN_SRC emacs-lisp
(use-package dired
  :hook
  (dired-mode . auto-revert-mode)
  (dired-mode . hl-line-mode)
  (dired-mode . dired-hide-details-mode)
  :custom
  (dired-listing-switches "-al --group-directories-first")
  ;; Always copy/delete recursively
  (dired-recursive-copies  'always)
  (dired-recursive-deletes 'top))
#+END_SRC

*** Editable
#+BEGIN_SRC emacs-lisp
(use-package wdired
  :preface
  (defvar-local +wdired-icons-enabled nil)
  (defun +wdired-before-start-advice ()
    "Execute when switching from `dired' to `wdired'."
    (setq +wdired-icons-enabled (if (bound-and-true-p all-the-icons-dired-mode)
                                    1 0))
    (when (bound-and-true-p all-the-icons-dired-mode)
      (all-the-icons-dired-mode 0)))
  (defun +wdired-after-finish-advice ()
    "Execute when switching from `wdired' to `dired'"
    (when (boundp 'all-the-icons-dired-mode)
      (all-the-icons-dired-mode +wdired-icons-enabled)))
  (advice-add 'wdired-change-to-wdired-mode :before #'+wdired-before-start-advice)
  (advice-add 'wdired-change-to-dired-mode :after #'+wdired-after-finish-advice)
  :general
  (:keymaps
   'dired-mode-map
   "C-c '" 'wdired-change-to-wdired-mode))
#+END_SRC

*** Sidebar
#+BEGIN_SRC emacs-lisp
(use-package dired-sidebar
  :hook
  (dired-sidebar-mode . hide-mode-line-mode)
  (dired-sidebar-mode . hl-line-mode)
  (dired-sidebar-mode . variable-pitch-mode)
  (dired-sidebar-mode . init-dired-sidebar)
  :general
  (:prefix
   init-leader-key
   "n" 'dired-sidebar-toggle-sidebar)
  :preface
  (defun init-dired-sidebar ()
    (setq cursor-type nil)
    (stripe-buffer-mode 0)))
#+END_SRC

*** Subtree
Display subtrees in dired view.
#+BEGIN_SRC emacs-lisp
(use-package dired-subtree
  :custom
  (dired-subtree-use-backgrounds nil)
  (dired-subtree-line-prefix "     "))
#+END_SRC

*** Stripes
Striped dired buffers.
#+BEGIN_SRC emacs-lisp
(use-package stripe-buffer
  :hook
  (dired-mode . stripe-buffer-mode))
#+END_SRC

*** Icons
#+BEGIN_SRC emacs-lisp
(use-package all-the-icons-dired
  :hook
  (dired-mode . all-the-icons-dired-mode))
#+END_SRC

*** Git
#+BEGIN_SRC emacs-lisp
(use-package dired-git-info
  :general
  (:keymaps
   'dired-mode-map
   ")" 'dired-git-info-mode))
#+END_SRC

** Occur
#+begin_src emacs-lisp :tangle yes
(use-package replace
  :general
  (:prefix
   init-search-prefix
   "o" 'occur)
  (:keymaps
   'occur-mode-map
   "C-c '" 'occur-edit-mode))
#+end_src

*** Packages
**** noccur
#+begin_src emacs-lisp :tangle yes
(use-package noccur
  :general
  (:prefix
   init-search-prefix
   "O" 'noccur-project))
#+end_src

** Packages
*** bibliothek
Management tool for a library of PDFs.
#+BEGIN_SRC emacs-lisp
(use-package bibliothek
  :custom
  (bibliothek-path '("~/books" "~/documents/research/papers"))
  (bibliothek-recursive t)
  :general
  (:prefix
   init-launch-prefix
   "b" 'bibliothek))
#+END_SRC

*** bookmark
Keep track of bookmarks
#+BEGIN_SRC emacs-lisp
(use-package bookmark
  :custom
  (bookmark-save-flag 1))
#+END_SRC

*** ctrlf
#+begin_src emacs-lisp :tangle yes
(use-package ctrlf
  :defer 2
  :config
  (ctrlf-mode 1))
#+end_src

*** deadgrep
#+BEGIN_SRC emacs-lisp
(use-package deadgrep
  :general
  (:prefix
   init-search-prefix
   "G" 'deadgrep)
  (:keymaps
   'deadgrep-mode-map
   "C-c '" 'deadgrep-edit-mode))
#+END_SRC

*** deft
#+BEGIN_SRC emacs-lisp
(use-package deft
  :custom
  (deft-auto-save-interval 0)
  (deft-directory (expand-file-name "~/org/"))
  (deft-extensions '("org" "md" "rst" "txt" "tex"))
  (deft-recursive t)
  (deft-use-filename-as-title t)
  (deft-use-filter-string-for-filename t)
  :general
  (:prefix
   init-launch-prefix
   "n" 'deft))
#+END_SRC

*** find-file
#+BEGIN_SRC emacs-lisp
(use-package find-file
  :init
  (setq-default ff-quiet-mode t)
  (put 'ff-search-directories 'safe-local-variable (lambda (x) (seq-every-p #'stringp x))))

(use-package ff-test :demand t)
#+END_SRC

*** find-file-rg
Find files via =rg --files=.
#+BEGIN_SRC emacs-lisp
(use-package find-file-rg
  :general
  ("C-c f" 'find-file-rg))
#+END_SRC

*** goto-last-change
Move point through buffer-undo-list positions.
#+BEGIN_SRC emacs-lisp
(use-package goto-chg
  :general
  (:prefix
   init-next-prefix
   "l" '(goto-last-change :wk "Change"))
  (:prefix
   init-prev-prefix
   "l" '(goto-last-change-reverse :wk "Change")))
#+END_SRC

*** link-hint
Hint mode for links.
#+BEGIN_SRC emacs-lisp
(use-package link-hint
  :general
  (:prefix init-nav-prefix
   "l" 'link-hint-open-link
   "L" 'link-hint-copy-link))
#+END_SRC

*** recentf
Keep track of recently opened files.
#+BEGIN_SRC emacs-lisp
(use-package recentf
  :defer 2
  :custom
  (recentf-exclude
   (list "/tmp/"                        ; Temp-files
         "/dev/shm"                     ; Potential secrets
         "/ssh:"                        ; Files over SSH
         "/nix/store"                   ; Files in Nix store
         "/TAGS$"                       ; Tag files
         "^/\\.git/.+$"                 ; Git contents
         "\\.?ido\\.last$"
         "\\.revive$"
         "^/var/folders/.+$"
         (concat "^" init-cache-dir ".+$")
         (concat "^" init-data-dir ".+$")))
  (recentf-filename-handlers '(abbreviate-file-name))
  (recentf-max-menu-items 0)
  (recentf-max-saved-items 300)
  (recentf-auto-cleanup 'never)
  :general
  ("C-c r" 'recentf-open-files+)
  :preface
  (defun completing-read-file-candidate (candidate)
    "Format `completing-read' file CANDIDATE with `abbreviate-file-name'
and icon prefix from `all-the-icons-icon-for-file'."
    (propertize (abbreviate-file-name candidate)
                'selectrum-candidate-display-prefix
                (concat (all-the-icons-icon-for-file candidate) "\t")))

  (defun recentf-open-files+ ()
    "Use `completing-read' to open a recent file."
    (interactive)
    (let ((files (cl-mapcar #'completing-read-file-candidate recentf-list)))
      (find-file (completing-read "Find recent file: " files nil t))))
  :config
  (init-quiet! (recentf-mode 1)))
#+END_SRC

*** saveplace
Keep track of last point place to resume editing in the same file.
#+BEGIN_SRC emacs-lisp
(use-package saveplace
  :defer 2
  :config
  (save-place-mode 1))
#+END_SRC

** Project
Project interactions. Prefix project buffer files with the project name and relative path.
#+BEGIN_SRC emacs-lisp
(use-package projectile
  :defer 2
  :custom
  (projectile-completion-system 'default)
  (projectile-enable-caching nil)
  (projectile-file-exists-remote-cache-expire nil)
  (projectile-globally-ignored-file-suffixes
   '(".elc" ".pyc" ".o" ".hi" ".class" ".cache"))
  (projectile-globally-ignored-files
   '("TAGS" "GPATH" "GRTAGS" "GTAGS"))
  (projectile-ignored-projects (list init-data-dir))
  (projectile-indexing-method 'alien)
  :general
  (:keymaps
   'projectile-mode-map
   [remap eshell] (general-predicate-dispatch #'eshell
                    :docstring "Creat an interactive Eshell buffer (project aware)"
                    (projectile-project-p) #'projectile-run-eshell)
   [remap term] (general-predicate-dispatch #'term
                  :docstring "Create an interactive terminal buffer (project aware)"
                  (projectile-project-p) #'projectile-run-term))
  (:keymaps
   'projectile-mode-map
   :prefix
   init-leader-key
   "p" '(:keymap projectile-command-map :package projectile :wk "project"))
  :preface
  (defun +projectile-cache-current-file (orig-fun &rest args)
    "Don't cache ignored files."
    (unless (cl-some (lambda (path)
                       (string-prefix-p buffer-file-name
                                        (expand-file-name path)))
                     (projectile-ignored-directories))
      (apply orig-fun args)))
  :init
  (advice-add #'projectile-cache-current-file :around #'+projectile-cache-current-file)
  (cl-pushnew '(setq projectile-project-root (locate-dominating-file buffer-file-name ".dir-locals.el"))
              safe-local-eval-forms
              :test #'equal)
  :config
  (setq projectile-globally-ignored-directories
        (append '("_build"
                  "target" "project/target"
                  "vendor/bundle" "vendor/cache"
                  "elm-stuff" "tests/elm-stuff")
                projectile-globally-ignored-directories))
  (setq projectile-other-file-alist
        (append '(("less" "css")
                  ("styl" "css")
                  ("sass" "css")
                  ("scss" "css")
                  ("css" "scss" "sass" "less" "styl")
                  ("jade" "html")
                  ("pug" "html")
                  ("html" "jade" "pug" "jsx" "tsx"))
                projectile-other-file-alist))
  (setq projectile-project-root-files
        (append '("package.json" "Package.swift" "README.md")
                projectile-project-root-files))

  (projectile-mode 1))
#+END_SRC

Manage project repositories.
#+BEGIN_SRC emacs-lisp
(use-package ivy-ghq
  :defer 2
  :custom
  (ivy-ghq-short-list t)
  :general
  ("C-c P" 'ivy-ghq-open))
#+END_SRC

* Completion
No completion with tab.
#+BEGIN_SRC emacs-lisp
(setq tab-always-indent t)
#+END_SRC

** Company
#+BEGIN_SRC emacs-lisp
(use-package company
  :custom
  (company-show-numbers t)
  (company-backends
   '((company-files
      company-keywords
      company-capf)))
  :hook
  (prog-mode . company-mode)
  :general
  (:keymaps
   'company-mode-map
   "C-?" 'company-complete)
  (:keymaps
   'company-active-map
   ;; No interference with return key
   [return]  'nil
   "RET"     'nil
   "C-e" 'company-complete-selection
   "C-f" 'company-complete-selection
   "C-n" 'company-select-next
   "C-p" 'company-select-previous))
#+END_SRC

** Hippie
Smart expansion completions, excellent for completing lines.
Replace abbrev completion (=M-/=) with hippie expand.

Complete in the following order:
- Try to expand word "dynamically", searching the current buffer.
- Try to expand word "dynamically", searching all other buffers.
- Try to expand word "dynamically", searching the kill ring.
- Try to complete text as a file name, as many characters as unique.
- Try to complete text as a file name.
- Try to expand word before point according to all abbrev tables.
- Try to complete the current line to an entire line in the buffer.
- Try to complete as an Emacs Lisp symbol, as many characters as unique.
- Try to complete word as an Emacs Lisp symbol.
#+BEGIN_SRC emacs-lisp
(use-package hippie-exp
  :commands
  (hippie-expand)
  :custom
  (hippie-expand-try-functions-list
   '(try-expand-dabbrev-visible
     try-expand-dabbrev
     try-complete-file-name-partially
     try-complete-file-name
     try-expand-all-abbrevs
     try-expand-list
     try-expand-line
     try-expand-line-all-buffers
     try-complete-lisp-symbol-partially
     try-complete-lisp-symbol))
  :general
  ([remap dabbrev-expand] 'hippie-expand))
#+END_SRC

** Selectrum
Incremental selection narrowing interface for completions.
#+begin_src emacs-lisp :tangle yes
(use-package selectrum
  :hook
  (after-init . selectrum-mode)
  :general
  ("C-c SPC" 'selectrum-repeat)
  :preface
  (defun selectrum-move-end-of-line-or-insert-current-candidate (arg)
    "Move to end of line or insert current candidate.
   ARG lines can be used."
    (interactive "p")
    (if (eolp) (selectrum-insert-current-candidate) (move-end-of-line arg)))
  :config
  (push (cons "C-e" 'selectrum-move-end-of-line-or-insert-current-candidate)
      selectrum-minibuffer-bindings))

(use-package selectrum-prescient
  :hook
  (selectrum-mode . selectrum-prescient-mode))

(use-package prescient
  :hook
  (after-init . prescient-persist-mode)
  (company-mode . company-prescient-mode))
#+end_src

** Ivy
#+BEGIN_SRC emacs-lisp
(use-package ivy
  :custom
  (ivy-hooks-alist '((t . hl-line-mode)))
  (ivy-wrap t)
  (ivy-on-del-error-function #'ignore)
  (ivy-use-virtual-buffers t)
  ;; Allow selecting the prompt as a candidate (e.g for creating a new file)
  (ivy-use-selectable-prompt t)
  (ivy-fixed-height-minibuffer t)
  ;; Don't use ^ as initial input.
  (ivy-initial-inputs-alist nil)
  :general
  (:keymaps
   'ivy-mode-map
   :prefix
   init-window-prefix
   "v" 'ivy-push-view
   "V" 'ivy-pop-view
   "'" 'ivy-switch-view)
  (:keymaps
   'ivy-occur-grep-mode-map
   "C-c '" 'ivy-wgrep-change-to-wgrep-mode)
  (:keymaps
   'ivy-minibuffer-map
   "C-<return>" 'ivy-immediate-done
   "C-e"        '+ivy-move-end-of-line-or-done
   "C-f"        '+ivy-forward-or-done
   "C-l"        'ivy-alt-done
   "C-u"        'ivy-kill-line
   "C-w"        'ivy-backward-kill-word)
  :preface
  (defun +ivy-move-end-of-line-or-done (arg)
    "Move to end of current line or consider ivy operation done.
   ARG lines can be used."
    (interactive "p")
    (if (eolp) (ivy-alt-done) (move-end-of-line arg)))
  (defun +ivy-forward-or-done (n)
    "Move point forward or consider ivy operation done.
      N characters can be used."
    (interactive "p")
    (if (eolp) (ivy-alt-done) (forward-char n))))
#+END_SRC

*** Packages
**** counsel
Replacements for common Emacs commands. =smex= is used by =counsel-M-x= for sorting.
Tips:
- =counsel-rg= can be used with =C-u= to search in a specific directory.
#+BEGIN_SRC emacs-lisp
(use-package counsel
  :custom
  (counsel-find-file-ignore-regexp
   "\\(?:^[#.]\\)\\|\\(?:[#~]$\\)\\|\\(?:^Icon?\\)")
  (counsel-grep-base-command
   "rg -i -M 120 --no-heading --line-number --color never '%s' %s")
  (counsel-mode-override-describe-bindings t)
  :general
  ("C-x /" 'counsel-abbrev)
  (:prefix init-search-prefix
   "g" 'counsel-rg)
  (:keymaps
   'counsel-ag-map
   "C-SPC" 'ivy-call-and-recenter)
  :config
  (defun counsel-abbrev (abbrev-name)
    "Insert abbreviation matching ABBREV-NAME."
    (interactive
     (list
      (ivy-completing-read
       "Insert abbrev: "
       (cl-loop for table in (abbrev--active-tables)
                unless (abbrev-table-empty-p table)
                append (append (delete 0 table) ())))))
    (progn
      (dolist (table (abbrev--active-tables))
        (when (abbrev-symbol abbrev-name table)
          (abbrev-insert (abbrev-symbol abbrev-name table))))))

  (defun counsel-maybe-git-cands ()
    (let ((root (counsel--git-root)))
      (when root
        (let ((concat-root-with
               (apply-partially 'concat (abbreviate-file-name root))))
          (cl-mapcar concat-root-with (counsel-git-cands root))))))

  (ivy-set-sources
   'counsel-recentf
   '((original-source)
     (counsel-maybe-git-cands))))
#+END_SRC

**** counsel-tramp
Navigate tramp files.
#+BEGIN_SRC emacs-lisp
(use-package counsel-tramp
  :general
  (:prefix
   init-leader-key
   "t" 'counsel-tramp))
#+END_SRC

**** ivy-xref
Support =xref= lookups.
#+BEGIN_SRC emacs-lisp
(use-package ivy-xref
  :init
  (setq xref-show-xrefs-function #'ivy-xref-show-xrefs))
#+END_SRC

**** ivy-yasnippet
Snippets with preview.
#+BEGIN_SRC emacs-lisp
(use-package ivy-yasnippet
  :general
  ([remap yas-insert-snippet] 'ivy-yasnippet)
  (:keymaps
   'yas-minor-mode-map
   :prefix
   init-leader-key
   "y" 'ivy-yasnippet))
#+END_SRC

* Development
Reduce scroll margin.
#+BEGIN_SRC emacs-lisp
(defun +prog-scroll-margin-setup ()
  "Setup `scroll-margin' for `prog-mode'."
  (setq-local scroll-margin 3))
(add-hook 'prog-mode-hook #'+prog-scroll-margin-setup)
#+END_SRC

** Compilation
Kill compilation process before stating another and save all buffers on =compile.=
#+BEGIN_SRC emacs-lisp
(use-package compile
  :custom
  (compilation-always-kill t)
  (compilation-ask-about-save nil)
  (compilation-scroll-output t)
  :general
  (:keymaps
   'global
   :prefix
   init-local-leader-key
   "c" 'recompile
   "C" 'compile)
  :init
  (put 'compile-command 'safe-local-variable 'stringp))

(make-variable-buffer-local 'compile-command)
#+END_SRC

*** ANSI escape
#+BEGIN_SRC emacs-lisp
(require 'ansi-color)
(defun +colorize-compilation ()
  "Colorize from `compilation-filter-start' to `point'."
  (let ((inhibit-read-only t))
    (ansi-color-apply-on-region compilation-filter-start (point))))
(add-hook 'compilation-filter-hook #'+colorize-compilation)
#+END_SRC

** Containers
*** Docker
#+BEGIN_SRC emacs-lisp
(use-package docker
  :general
  (:prefix
   init-leader-key
   "d" 'docker
   "c" 'docker-compose))
#+END_SRC

**** Files
Support for Docker related files.
#+BEGIN_SRC emacs-lisp
(use-package dockerfile-mode)
(use-package docker-compose-mode)
#+END_SRC

**** Tramp
#+BEGIN_SRC emacs-lisp
(use-package docker-tramp
  :defer 2
  :custom
  (docker-tramp-use-names t))
#+END_SRC

*** Kubernetes
#+BEGIN_SRC emacs-lisp
(use-package kubernetes)
#+END_SRC

**** Tramp
#+BEGIN_SRC emacs-lisp
(use-package kubernetes-tramp :defer 2)
#+END_SRC

** Coverage
#+BEGIN_SRC emacs-lisp
(use-package coverlay
  :hook
  (coverlay-minor-mode . init-coverlay)
  :custom
  (coverlay:mark-tested-lines nil)
  :general
  (:prefix
   init-local-leader-key
   "v" 'coverlay-mode-toggle)
  :init
  (defun init-coverlay ()
    "Setup `coverlay-mode'."
    (setq-local
     coverlay:base-path
     (expand-file-name (locate-dominating-file (file-name-directory (buffer-file-name))
                                               "coverage"))))
  (defun coverlay-mode-toggle ()
    "Turn on `coverlay-mode'."
    (interactive)
    (if (bound-and-true-p coverlay-minor-mode)
        (coverlay-minor-mode 0)
      (coverlay-minor-mode 1)
      (when (and (buffer-file-name) (not (bound-and-true-p coverlay--loaded-filepath)))
        (let ((coverage-file (expand-file-name "coverage/lcov.info" coverlay:base-path)))
          (when (file-exists-p coverage-file)
            (coverlay-watch-file coverage-file)))))))
#+END_SRC

** Docs
*** DevDocs
Lookup documentation via DevDocs.
#+BEGIN_SRC emacs-lisp
(use-package devdocs
  :general
  ("M-g K" 'devdocs-search))
#+END_SRC

** Editing
*** separedit
#+BEGIN_SRC emacs-lisp
(use-package separedit
  :custom
  (separedit-preserve-string-indentation t)
  :general
  (:keymaps
   '(prog-mode-map typescript-mode-map)
   "C-c '" 'separedit))
#+END_SRC

** Eval
*** quickrun
#+BEGIN_SRC emacs-lisp
(use-package quickrun
  :hook
  (quickrun--mode . init-display-ctrl-M-as-newline)
  :general
  (:prefix
   init-local-leader-key
   "q" 'quickrun
   "Q" 'quickrun-autorun-mode))
#+END_SRC

** Folding
Code folding.
#+BEGIN_SRC emacs-lisp
(use-package hideshow
  :hook (prog-mode . hs-minor-mode)
  :custom
  (hs-hide-comments-when-hiding-all nil)
  :general
  (:prefix
   (concat init-leader-key " " "z")
   ""      '(:ignore t :wk "hide")
   "c"     'hs-hide-block
   "o"     'hs-show-block
   "C"     'hs-hide-all
   "O"     'hs-show-all
   "l"     'hs-hide-level
   "z"     'hs-toggle-hiding
   "<tab>" 'hs-toggle-hiding)
  :preface
  (defun +hs-fold-overlay-ellipsis (ov)
    (when (eq 'code (overlay-get ov 'hs))
      (overlay-put
       ov 'display (propertize " … " 'face 'font-lock-comment-face))))
  :init
  (setq hs-allow-nesting t
        hs-set-up-overlay #'+hs-fold-overlay-ellipsis))
#+END_SRC

** Formatting
*** apheleia
Reformat buffer without moving point.
#+BEGIN_SRC emacs-lisp
(use-package apheleia
  :init
  (put 'apheleia-formatter 'safe-local-variable 'symbolp)
  :config
  (progn ;; JavaScript/TypeScript
    (cl-pushnew '(eslint . (npx "eslint_d" "--fix-to-stdout" "--stdin" "--stdin-filename" file)) apheleia-formatters :test #'equal))
  (progn ;; Nix
    (cl-pushnew '(nixfmt . ("nixfmt")) apheleia-formatters :test #'equal))
  (progn ;; Ruby
    (cl-pushnew '(rufo . ("rufo" "--simple-exit")) apheleia-formatters :test #'equal)
    (cl-pushnew '(ruby-mode . rufo) apheleia-mode-alist :test #'equal)))
#+END_SRC

*** reformatter
Custom formatters. Use in a specific project via =.dir-locals.el=, this can be achieved via
the mode mechanism:
#+BEGIN_SRC text
((some-major-mode
   (mode . FORMATTER-on-save)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package reformatter
  :demand t
  :config
  (reformatter-define nixfmt :program "nixfmt"))
#+END_SRC

** Jump to definition
Jump to definition is really useful and I prefer doing so without TAGS which is pretty
much the default for most modes. I am using the excellent package =dumb-jump= to jump via
grep tools e.g. (=grep=, =rx=, =ag=)

Don't ask about keeping current list of tags tables.
#+BEGIN_SRC emacs-lisp
(use-package etags
  :custom
  (tags-add-tables nil))
#+END_SRC

*** dumb-jump
#+BEGIN_SRC emacs-lisp
(use-package dumb-jump
  :custom
  (dumb-jump-default-project user-emacs-directory)
  :general
  (:prefix
   init-nav-prefix
   "i" 'dumb-jump-go-prompt
   "o" 'dumb-jump-go-other-window
   "x" 'dumb-jump-go-prefer-external
   "z" 'dumb-jump-go-prefer-external-other-window))
#+END_SRC

*** smart-jump
Some modes actually have some good backends, so configure this with =smart-jump= which has
nice defaults and also adds configuring completion with a fallback to =dumb-jump=.
#+BEGIN_SRC emacs-lisp
(use-package smart-jump
  :defer 2
  :custom
  (smart-jump-find-references-fallback-function #'smart-jump-find-references-with-counsel-rg)
  (smart-jump-default-mode-list
   '(clojure-mode
     eglot
     elisp-mode
     elixir-mode
     elm-mode
     erlang-mode
     go-mode
     lisp-mode
     lua-mode
     python))
  :general
  ("M-." 'smart-jump-go)
  ("M-," 'smart-jump-back)
  ("M-?" 'smart-jump-references)
  (:prefix
   init-nav-prefix
   "j" 'smart-jump-go
   "r" 'smart-jump-references)
  :preface
  (defun smart-jump-find-references-with-counsel-rg ()
    "Use `rg' and `counsel' to find references."
    (interactive)
    (if (fboundp 'counsel-rg)
        (counsel-rg
         (cond ((use-region-p)
                (buffer-substring-no-properties (region-beginning)
                                                (region-end)))
               ((symbol-at-point)
                (substring-no-properties
                 (symbol-name (symbol-at-point))))))
      (message "Install counsel to use `smart-jump-simple-find-references-with-counsel-rg'.")))
  :config
  (smart-jump-setup-default-registers))
#+END_SRC

** Refactor
Refactoring commands for various languages.
#+BEGIN_SRC emacs-lisp
(use-package emr
  :general
  (:keymaps
   'prog-mode-map
   "M-<return>" 'emr-show-refactor-menu))
#+END_SRC

** REPL
*** comint
#+BEGIN_SRC emacs-lisp
(use-package comint
  :custom
  (comint-use-prompt-regexp t)
  :preface
  (defun comint-process-tab-complete ()
    "Complete by sending the current input and TAB character to the process."
    (interactive)
    (let* ((buffer (current-buffer))
           (pmark (process-mark (get-buffer-process buffer))))
      (when (> (point) (marker-position pmark))
        (kill-region pmark (point))
        (comint-send-string buffer (concat (pop kill-ring) "\t")))))
  :general
  (:keymaps
   'comint-mode-map
   "<tab>" 'comint-process-tab-complete
   "C-c C-k" 'term-char-mode))
#+END_SRC

*** repl-toggle
#+BEGIN_SRC emacs-lisp
(use-package repl-toggle
  :custom
  (rtog/goto-buffer-fun 'pop-to-buffer)
  (rtog/mode-repl-alist '((emacs-lisp-mode . ielm)
                          (clojure-mode . clojure-repl)
                          (elm-mode . elm-repl-load)
                          (go-mode . gorepl-run)
                          (js-mode . js-repl)
                          (lisp-mode . slime)
                          (lua-mode . lua-repl)
                          (nix-mode . nix-repl)
                          (racket-mode . racket-repl)
                          (typescript-mode . run-ts)))
  :general
  (:keymaps
   'prog-mode-map
   :prefix init-local-leader-key
   "r" 'rtog/toggle-repl)
  :preface
  (defun clojure-repl ()
    "Open a Clojure REPL."
    (interactive)
    (pop-to-buffer (cider-current-repl nil 'ensure)))

  (defun js-repl ()
    "Open a JavaScript REPL."
    (interactive)
    (if (indium-client-process-live-p) (indium-switch-to-repl-buffer) (nodejs-repl)))

  (defun lua-repl ()
    "Open a Lua REPL."
    (interactive)
    (pop-to-buffer (process-buffer (lua-get-create-process)))))
#+END_SRC

*** Persistent history in comint
#+BEGIN_SRC emacs-lisp
(defun +comint-history-write-on-exit (process event)
  "Write `comint' history on exit.
Receives PROCESS and EVENT."
  (comint-write-input-ring)
  (let ((buf (process-buffer process)))
    (when (buffer-live-p buf)
      (with-current-buffer buf
        (insert (format "\nProcess %s %s" process event))))))

(defun +comint-history-enable ()
  "Enable `comint' history."
  (let ((process (get-buffer-process (current-buffer))))
    (when process
      (setq comint-input-ring-file-name
            (expand-file-name
             (format "comint-%s-history" (process-name process))
             init-cache-dir))
      (comint-read-input-ring)
      (set-process-sentinel process #'+comint-history-write-on-exit))))
#+END_SRC

** Syntax checker
Silence next/previous error, by default it produces a message every time.
#+BEGIN_SRC emacs-lisp
(advice-add #'next-error :around #'init-quiet-function-advice)
(advice-add #'previous-error :around #'init-quiet-function-advice)
#+END_SRC

*** flymake
Connect flymake to =next-error-function= and add some navigation bindings. Disable the
legacy diagnostic functions as some of them have bugs and cause instability (mainly the
Haskell one).
#+BEGIN_SRC emacs-lisp
(use-package flymake
  :hook
  (flymake-mode . +flymake-setup-next-error-function)
  :custom
  (help-at-pt-timer-delay 0.1)
  (help-at-pt-display-when-idle '(flymake-diagnostic))
  (flymake-proc-ignored-file-name-regexps '("\\.l?hs\\'"))
  :general
  (:keymaps
   'flymake-mode-map
   :prefix
   init-local-leader-key
   "!" 'flymake-show-diagnostics-buffer)
  (:keymaps
   'flymake-mode-map
   :prefix init-next-prefix
   "E" 'flymake-goto-next-error)
  (:keymaps
   'flymake-mode-map
   :prefix init-prev-prefix
   "E" 'flymake-goto-prev-error)
  (:keymaps
   'flymake-diagnostics-buffer-mode-map
   "n" '+flymake-diagnostics-next-error
   "p" '+flymake-diagnostics-prev-error
   "j" '+flymake-diagnostics-next-error
   "k" '+flymake-diagnostics-prev-error
   "RET" 'flymake-goto-diagnostic
   "TAB" 'flymake-show-diagnostic)
  :preface
  (defun +flymake-setup-next-error-function ()
    (setq next-error-function 'flymake-goto-next-error))

  (defun +flymake-diagnostics-next-error ()
    (interactive)
    (forward-line)
    (when (eobp) (forward-line -1))
    (flymake-show-diagnostic (point)))

  (defun +flymake-diagnostics-prev-error ()
    (interactive)
    (forward-line -1)
    (flymake-show-diagnostic (point)))
  :init
  (remove-hook 'flymake-diagnostic-functions 'flymake-proc-legacy-flymake))
#+END_SRC

**** Diagnostics at point
#+BEGIN_SRC emacs-lisp
(use-package flymake-diagnostic-at-point
  :hook
  (flymake-mode . flymake-diagnostic-at-point-mode)
  :preface
  (defun flymake-diagnostic-at-point-quick-peek (text)
    "Display the flymake diagnostic TEXT with `quick-peek'`."
    (quick-peek-show (concat flymake-diagnostic-at-point-error-prefix text)))
  :custom
  (flymake-diagnostic-at-point-error-prefix nil))
#+END_SRC

** Version control
#+BEGIN_SRC emacs-lisp
(setq vc-follow-symlinks t
      vc-make-backup-files nil)
#+END_SRC

*** browse-at-remote
Open link to files in the web UI connected to a repository.
#+begin_src emacs-lisp
(use-package browse-at-remote
  :general
  ("C-x v SPC" 'browse-at-remote))
#+end_src

*** ediff
- Split horizontally
- Use existing frame instead of creating a new one
- Add a third resolution option, copy both A and B to C
#+BEGIN_SRC emacs-lisp
(use-package ediff
  :hook
  (ediff-quit . winner-undo)
  (ediff-keymap-setup . init-ediff-keys)
  :custom
  (ediff-diff-options "-w")
  (ediff-merge-split-window-function #'split-window-horizontally)
  (ediff-split-window-function #'split-window-horizontally)
  (ediff-window-setup-function #'ediff-setup-windows-plain)
  :preface
  (defun ediff-copy-both-to-C ()
    "Copy change from both A and B to C."
    (interactive)
    (ediff-copy-diff
     ediff-current-difference nil 'C nil
     (concat
      (ediff-get-region-contents ediff-current-difference 'A ediff-control-buffer)
      (ediff-get-region-contents ediff-current-difference 'B ediff-control-buffer))))

  (defun init-ediff-keys ()
    "Setup keybindings for `ediff-mode'."
    (general-define-key
     :keymaps 'ediff-mode-map
     "d" '(ediff-copy-both-to-C      :wk "Copy both to C")
     "j" '(ediff-next-difference     :wk "Next difference")
     "k" '(ediff-previous-difference :wk "Previous difference"))))
#+END_SRC

*** diff-hl
Diff indicators in fringe
#+BEGIN_SRC emacs-lisp
(use-package diff-hl
  :defer 2
  :custom
  (diff-hl-ask-before-revert-hunk nil)
  :hook
  (dired-mode         . diff-hl-dired-mode)
  (magit-post-refresh . diff-hl-magit-post-refresh)
  :commands
  (diff-hl-next-hunk
   diff-hl-previous-hunk)
  :preface
  (autoload 'diff-hl-flydiff-mode "diff-hl-flydiff" nil t)
  (autoload 'diff-hl-dired-mode "diff-hl-dired" nil t)
  :config
  (global-diff-hl-mode 1)
  (diff-hl-flydiff-mode 1))
#+END_SRC

*** magit
Enhanced git related views and commands.
#+BEGIN_SRC emacs-lisp
(use-package magit
  :defer 2
  :hook
  (git-commit-mode . +git-commit-set-fill-column)
  :custom
  (magit-log-buffer-file-locked t)
  (magit-refs-show-commit-count 'all)
  (magit-save-repository-buffers 'dontask)
  (vc-msg-git-show-commit-function 'magit-show-commit)
  :preface
  (defun +git-commit-set-fill-column ()
    "Set `fill-column' for git commit."
    (setq fill-column 72))

  (defvar init-magit-process-create-pull-request-regexp
    "remote: Create pull request for.*\nremote: +\\(?1:[^ ]+\\)[^\n]*"
    "Regular expression detecting PR.")

  (defun init-magit-process-ask-create-pull-request (_process string)
    "Detect pull request STRING and ask to create PR."
    (when (string-match init-magit-process-create-pull-request-regexp string)
      (let ((url (match-string 1 string))
            (inhibit-message t))
        (if (y-or-n-p "Create PR?")
            (browse-url (url-encode-url url))))))
  :config
  (setq magit-process-prompt-functions #'init-magit-process-ask-create-pull-request)
  ;; Unset pager as it is not supported properly inside emacs.
  (setenv "GIT_PAGER" "")
  (global-magit-file-mode 1))
#+END_SRC

*** vc-msg
Popup commit message for current line
#+BEGIN_SRC emacs-lisp
(use-package vc-msg
  :general
  ("C-x v p" 'vc-msg-show))
#+END_SRC

** Packages
*** envrc
Project-specific environment variables via =direnv=.
#+BEGIN_SRC emacs-lisp
(use-package envrc
  :if (executable-find "direnv")
  :defer 1
  :general
  (:keymaps
   'envrc-mode-map
   "C-c e" 'envrc-command-map)
  :config
  (envrc-global-mode 1))
#+END_SRC

*** editorconfig
Use [[https://editorconfig.org/][EditorConfig]] to maintain the coding styles used across different projects.
#+BEGIN_SRC emacs-lisp
(use-package editorconfig
  :defer 1
  :custom
  (editorconfig-trim-whitespaces-mode 'ws-butler-mode)
  :config
  (dolist (mode '(emacs-lisp-mode lisp-mode))
    (setq editorconfig-indentation-alist
          (assq-delete-all mode editorconfig-indentation-alist)))
  (editorconfig-mode 1))
#+END_SRC

*** eglot
Generic Language Server Protocol integration via =eglot=.
#+BEGIN_SRC emacs-lisp
(use-package eglot
  :defer 3
  :hook
  ((haskell-mode
    java-mode
    ruby-mode
    rustic-mode
    typescript-mode) . eglot-ensure)
  (js-mode . +eglot-ensure-unless-json-mode)
  :preface
  (defun +eglot-ensure-unless-json-mode ()
    (unless (derived-mode-p 'json-mode) (eglot-ensure)))
  :custom
  (eglot-autoshutdown t)
  (eglot-confirm-server-initiated-edits nil)
  (eglot-sync-connect nil)
  :general
  (:keymaps
   'eglot-mode-map
   "M-g k" 'eglot-help-at-point)
  (:keymaps
   'eglot-mode-map
   :prefix init-local-leader-key
   "e" '(:ignore t :wk "eglot")
   "ea" 'eglot-code-actions
   "ef" 'eglot-format
   "eh" 'eglot-help-at-point
   "er" 'eglot-rename)
  :config
  (cl-pushnew '(typescript-mode . ("javascript-typescript-stdio"))
              eglot-server-programs
              :test #'equal))
#+END_SRC

*** helm-make
Execute make tasks.
#+BEGIN_SRC emacs-lisp
(use-package helm-make
  :custom
  (helm-make-completion-method 'ivy)
  :general
  (:prefix
   init-leader-key
   "m" (general-predicate-dispatch #'helm-make
         :docstring "Run make task (project aware)"
         (projectile-project-p) #'helm-make-projectile)))
#+END_SRC

*** hl-todo
Highlight *TODO* inside comments and strings.
#+BEGIN_SRC emacs-lisp
(use-package hl-todo
  :hook
  (prog-mode . hl-todo-mode)
  :commands
  (hl-todo-next
   hl-todo-previous))
#+END_SRC

*** idle-highlight
Highlight symbol at point on idle.
#+BEGIN_SRC emacs-lisp
(use-package idle-highlight-mode
  :hook prog-mode)
#+END_SRC

*** imenu-anywhere
Jump to document locations in current buffer
#+BEGIN_SRC emacs-lisp
(use-package imenu-anywhere
  :general
  (:prefix
   init-search-prefix
   "i" 'imenu
   "I" 'imenu-anywhere))
#+END_SRC

*** imenu-list
Document locations in a sidebar.
#+BEGIN_SRC emacs-lisp
(use-package imenu-list
  :general
  (:prefix
   init-leader-key
   "i" 'imenu-list-smart-toggle))
#+END_SRC

*** source-peek
Peek definition (Display the function source inline).
#+BEGIN_SRC emacs-lisp
(use-package source-peek
  :general
  (:prefix
   init-nav-prefix
   "SPC" 'source-peek))
#+END_SRC

*** ws-butler
Delete trailing white-space before save, but *only* for edited lines.
#+BEGIN_SRC emacs-lisp
(use-package ws-butler
  :custom
  (ws-butler-convert-leading-tabs-or-spaces t)
  :commands
  (ws-butler-mode))
#+END_SRC

** Appearance
*** Highlight delimiters
Visually separate delimiter pairs.
#+BEGIN_SRC emacs-lisp
(use-package rainbow-delimiters
  :custom
  (rainbow-delimiters-max-face-count 3)
  :hook
  ((clojure-mode
    emacs-lisp-mode
    ielm-mode
    lisp-mode
    racket-mode) . rainbow-delimiters-mode))
#+END_SRC

*** Highlight identifiers
Highlight source code identifiers based on their name.
#+BEGIN_SRC emacs-lisp
(use-package color-identifiers-mode
  :defer 2
  :config
  (cl-pushnew '(js-mode . ("[^.][[:space:]]*"
                            "\\_<\\([a-zA-Z_$]\\(?:\\s_\\|\\sw\\)*\\)"
                            (nil font-lock-variable-name-face js2-function-param)
                            "[a-zA-Z_$]+[(:]"))
              color-identifiers:modes-alist
              :test #'equal)
  (cl-pushnew '(rjsx-mode . ("[^.][[:space:]]*"
                            "\\_<\\([a-zA-Z_$]\\(?:\\s_\\|\\sw\\)*\\)"
                            (nil font-lock-variable-name-face js2-function-param)
                            "[a-zA-Z_$]+[(:]"))
              color-identifiers:modes-alist
              :test #'equal)
  (cl-pushnew '(typescript-mode . ("[^.][[:space:]]*"
                                   "\\_<\\([a-zA-Z_$]\\(?:\\s_\\|\\sw\\)*\\)"
                                   (nil font-lock-variable-name-face)
                                   "[a-zA-Z_$]+[(:]"))
              color-identifiers:modes-alist
              :test #'equal)
  (global-color-identifiers-mode 1))

(use-package rainbow-identifiers
  :custom
  (rainbow-identifiers-choose-face-function 'rainbow-identifiers-cie-l*a*b*-choose-face))
#+END_SRC

*** Highlight numbers
For modes that don't adequately highlight numbers.
#+BEGIN_SRC emacs-lisp
(use-package highlight-numbers
  :hook (prog-mode . highlight-numbers-mode))
#+END_SRC

*** Prettify symbols
#+BEGIN_SRC emacs-lisp
(use-package prog-mode
  :hook
  (prog-mode . init-prog-prettify-symbols)
  :custom
  (prettify-symbols-unprettify-at-point t)
  :preface
  (defun init-prog-prettify-symbols ()
    "Add generic programming symbols."
    (dolist (symbol '(("&&" . (?\s (Br . Bl) ?\s (Bc . Bc) ?∧))
                      ("||" . (?\s (Br . Bl) ?\s (Bc . Bc) ?∨))
                      (":=" . (?: (Br . Bc) ?= (Br . Bc) ?=))
                      ("==" . (?≡ (Br . Bc) ?≡ (Br . Bc) ?≡))
                      ("===" . (?≡ (Br . Bc) ?≡ (Br . Bc) ?≡))
                      ("!==" . (?≡ (Br . Bc) ?≢ (Br . Bc) ?≡))
                      (">="  . (?\s (Br . Bl) ?\s (Bc . Bc) ?≥))
                      ("<="  . (?\s (Br . Bl) ?\s (Bc . Bc) ?≤))
                      ("/=" . (?≡ (Br . Bc) ?≢ (Br . Bc) ?≡))
                      ("!=" . (?≡ (Br . Bc) ?≢ (Br . Bc) ?≡))
                      ("<-" . (?< (Br . Bc) ?- (Br . Bc) ?-))
                      ("->" . (?- (Br . Bc) ?- (Br . Bc) ?>))
                      ("<==" . (?< (Br . Bc) ?= (Br . Bc) ?=))
                      ("==>" . (?= (Br . Bc) ?= (Br . Bc) ?>))
                      ("lambda" . ?λ)))
      (cl-pushnew symbol prettify-symbols-alist :test #'equal))
    (prettify-symbols-mode 1)))
#+END_SRC

* Major modes
** elisp
#+BEGIN_SRC emacs-lisp
(add-hook 'emacs-lisp-mode-hook #'flymake-mode)

(general-define-key
 :keymaps 'emacs-lisp-mode-map
 :prefix init-local-leader-key
 "c" 'emacs-lisp-byte-compile
 "C" 'emacs-lisp-byte-compile-and-load
 "t" 'ert)

(custom-set-variables
 '(ad-redefinition-action 'accept)
 '(apropos-do-all t)
 '(enable-local-eval 'maybe)
 '(enable-local-variables :safe))
#+END_SRC

Specific safe local code can be specified via:
- =safe-local-variable-values=
- =safe-local-eval-forms=
- =safe-local-eval-function=

*** ielm
Persist ielm history.
#+BEGIN_SRC emacs-lisp
(defvar +ielm-comint-input-ring nil)
(with-eval-after-load 'savehist
  (cl-pushnew '+ielm-comint-input-ring savehist-additional-variables :test #'equal))

(defun +ielm-set-comint-input-ring ()
  "Restore `ielm' history."
  (setq-local comint-input-ring-size 200)
  (add-hook 'kill-buffer-hook #'+ielm-save-comint-input-ring nil t)
  (when +ielm-comint-input-ring
    (setq comint-input-ring +ielm-comint-input-ring)))

(defun +ielm-save-comint-input-ring ()
  "Save `ielm' history."
  (setq +ielm-comint-input-ring comint-input-ring))

(add-hook 'ielm-mode-hook #'+ielm-set-comint-input-ring)
#+END_SRC

*** eval-expression
Highlight parenthesis.
#+BEGIN_SRC emacs-lisp
(add-hook 'eval-expression-minibuffer-setup-hook #'show-paren-mode)
#+END_SRC

*** Packages
**** auto-compile
Auto-compile Elisp files.
#+BEGIN_SRC emacs-lisp
(use-package auto-compile
  :hook
  (emacs-lisp-mode . auto-compile-on-load-mode)
  (emacs-lisp-mode . auto-compile-on-save-mode)
  :custom
  (auto-compile-display-buffer nil)
  (auto-compile-use-mode-line nil))
#+END_SRC

**** eros
Evaluation results in overlay.
#+BEGIN_SRC emacs-lisp
(use-package eros
  :hook
  (emacs-lisp-mode . eros-mode))
#+END_SRC

**** helpful
Better =*help*= buffer
#+BEGIN_SRC emacs-lisp
(use-package helpful
  :general
  (:keymaps
   'emacs-lisp-mode-map
   :prefix init-nav-prefix
   "h" 'helpful-at-point)
  (:keymaps
   'help-map
   "C" 'helpful-command
   "f" 'helpful-function
   "F" 'helpful-callable
   "k" 'helpful-key
   "M" 'helpful-macro
   "v" 'helpful-variable)
  (:keymaps
   'helpful-mode-map
   "[[" 'backward-button
   "]]" 'forward-button))
#+END_SRC

**** highlight-quoted
#+BEGIN_SRC emacs-lisp
(use-package highlight-quoted
  :hook
  (emacs-lisp-mode . highlight-quoted-mode))
#+END_SRC

**** package-lint-flymake
#+BEGIN_SRC emacs-lisp
(use-package package-lint-flymake
  :hook
  (emacs-lisp-mode . package-lint-flymake-setup))
#+END_SRC

**** suggest
Discover functions.
#+BEGIN_SRC emacs-lisp
(use-package suggest
  :commands
  (suggest)
  :general
  (:keymaps
   'emacs-lisp-mode-map
   :prefix init-local-leader-key
   "s" '+suggest-popup)
  :preface
  (defun +suggest-popup ()
    "Open suggest as a popup."
    (interactive)
    (let* ((window         (selected-window))
           (dedicated-flag (window-dedicated-p window)))
      (set-window-dedicated-p window t)
      (suggest)
      (set-window-dedicated-p window dedicated-flag))))
#+END_SRC

*** Appearance
**** Package prefixes
Shorten package prefixes.
#+BEGIN_SRC emacs-lisp
(use-package nameless
  :hook
  (emacs-lisp-mode . nameless-mode))
#+END_SRC

**** Prettify symbols
#+BEGIN_SRC emacs-lisp
(defun init-emacs-lisp-prettify-symbols ()
  "Prettify `emacs-lisp-mode' specific symbols."
  (dolist (symbol '(("defun"    . ?ƒ)
                    ("defmacro" . ?μ)
                    ("defvar"   . ?ν)
                    ("defconst" . "ν_")))
    (cl-pushnew symbol prettify-symbols-alist :test #'equal)))
(add-hook 'emacs-lisp-mode-hook #'init-emacs-lisp-prettify-symbols)
#+END_SRC

**** Regular expression escapes
Improve readability of escape characters in regular expressions.
#+BEGIN_SRC emacs-lisp
(use-package easy-escape
  :hook
  (emacs-lisp-mode . easy-escape-minor-mode))
#+END_SRC

** erc
#+BEGIN_SRC emacs-lisp
(use-package erc
  :hook
  (erc-mode . init-erc-parens)
  :custom
  (erc-hide-list '("JOIN" "PART" "QUIT"))
  (erc-prompt-for-password nil)
  :preface
  (defun init-erc-parens ()
    "Parenthesis configuration for `erc-mode'."
    (smartparens-strict-mode 0)
    (smartparens-mode 1)))
#+END_SRC

** eshell
#+BEGIN_SRC emacs-lisp
(use-package eshell
  :hook
  (eshell-mode . abbrev-mode)
  (eshell-mode . init-eshell-define-keys)
  (eshell-mode . init-eshell-set-visual-commands)
  :custom
  (eshell-buffer-maximum-lines 20000)
  (eshell-history-size 1000)
  (eshell-hist-ignoredups t)
  (eshell-error-if-no-glob t)
  (eshell-destroy-buffer-when-process-dies t)
  :general
  (:prefix
   init-launch-prefix
   "t" 'eshell)
  :preface
  (defvar eshell-visual-commands)
  (defun init-eshell-define-keys ()
    (general-define-key
     :keymaps 'eshell-mode-map
     "RET" '+eshell-expand-abbrev-and-send-input
     "<tab>" 'completion-at-point
     "C-r" 'counsel-esh-history))

  (defun init-eshell-set-visual-commands ()
    (setq eshell-visual-commands
          (append
           '("fish" "ghcid" "jshell" "most" "ssh" "tail" "tsun" "watch")
           eshell-visual-commands)))
  :init
  (autoload 'eshell-smart-initialize "em-smart"))
#+END_SRC

*** Abbreviations
Fish-like abbreviations that expand on space or enter.
#+BEGIN_SRC emacs-lisp
(defun +eshell-expand-abbrev-and-send-input ()
  "Expand abbreviation and send input to `eshell'."
  (interactive)
  (expand-abbrev)
  (call-interactively #'eshell-send-input))

(defun +eshell-abbrev-expand-p ()
  "Return t if abbreviation should be expanded.
Expansion should happen when abbreviation is at the beginning of
the line or after an eshell operator."
  (let* ((end (point-marker))
         (begin (save-excursion (eshell-bol) (point)))
         (args (catch 'eshell-incomplete (eshell-parse-arguments begin end))))
    (or (= 1 (length args))
        (let ((last-two-args (last args 2)))
          (and (consp (car last-two-args))
               (eq (caar last-two-args)
                   'eshell-operator))))))

(define-abbrev-table 'eshell-mode-abbrev-table
  '(("base64" "base64 -w0")
    ("d" "docker")
    ("dim" "docker images")
    ("dp" "docker ps")
    ("dc" "docker-compose")
    ("dcl" "docker-compose logs")
    ("e" "find-file-other-window")
    ("E" "dired")
    ("gd" "magit-diff-unstaged")
    ("gds" "magit-diff-staged")
    ("gs" "magit-status")
    ("time" "time -p")
    ("tree" "tree -a")
    ("week" "date '+%V'"))
  :enable-function #'+eshell-abbrev-expand-p)
#+END_SRC

*** Packages
**** eshell-fringe-status
Command execution status indicator in the fringe.
#+BEGIN_SRC emacs-lisp
(use-package eshell-fringe-status
  :hook
  (eshell-mode . eshell-fringe-status-mode))
#+END_SRC

**** esh-autosuggest
Autosuggestions from history similar to fish.
#+BEGIN_SRC emacs-lisp
(use-package esh-autosuggest
  :hook
  (eshell-mode . esh-autosuggest-mode)
  :general
  (:keymaps
   'esh-autosuggest-active-map
   "C-e" 'company-complete-selection))
#+END_SRC

**** fish-completion
Populate auto-completions from fish.
#+BEGIN_SRC emacs-lisp
(use-package fish-completion
  :hook
  (eshell-mode . fish-completion-mode))
#+END_SRC

** org
#+BEGIN_SRC emacs-lisp
(use-package org
  :hook
  (org-mode . auto-fill-mode)
  :minor
  ("init\\.org\\'" . auto-tangle-mode)
  :custom
  (org-agenda-files '("~/org"))
  (org-confirm-babel-evaluate nil)
  (org-babel-load-languages
   '((emacs-lisp . t)
     (clojure    . t)
     (js         . t)
     (plantuml   . t)
     (shell      . t)))
  (org-edit-src-content-indentation 0)
  (org-log-done 'time)
  (org-modules nil)
  (org-plantuml-exec-mode 'plantuml)
  (org-special-ctrl-a/e t)
  (org-src-preserve-indentation nil)
  (org-src-tab-acts-natively t)
  (org-src-window-setup 'current-window)
  (org-tag-alist
   '(("@work"  . ?w)
     ("@home"  . ?h)
     ("laptop" . ?l)))
  :general
  (:keymaps
   'org-mode-map
   "C-'" 'nil
   "C-," 'nil)
  :functions
  (org-babel-load-languages)
  :preface
  (autoload 'org-get-outline-path "org-refile" nil t)
  :config
  (org-babel-do-load-languages 'org-babel-load-languages org-babel-load-languages))
#+END_SRC

*** Packages
**** org-babel-eval-in-repl
Evaluation of source code blocks in REPL.
#+BEGIN_SRC emacs-lisp
(use-package org-babel-eval-in-repl
  :general
  (:keymaps
   'org-mode-map
   "C-<return>" '+org-ctrl-return
   "M-<return>" '+org-meta-return)
  :preface
  (defun +org-ctrl-return ()
    "Run `ober-eval-in-repl' if in source code block and `org-insert-heading-respect-content' otherwise."
    (interactive)
    (if (org-in-block-p '("src" "example"))
        (ober-eval-in-repl)
      (call-interactively #'org-insert-heading-respect-content)))
  (defun +org-meta-return ()
    "Run `ober-eval-block-in-repl' if in source code block or example block and `org-meta-return' otherwise."
    (interactive)
    (if (org-in-block-p '("src" "example"))
        (ober-eval-block-in-repl)
      (call-interactively #'org-meta-return))))
#+END_SRC

**** org-cliplink
Paste links from clipboard and automatically fetch title.
#+BEGIN_SRC emacs-lisp
(use-package org-cliplink
  :general
  (:keymaps
   'org-mode-map
   :prefix init-local-leader-key
   "l" 'org-cliplink))
#+END_SRC

**** org-noter
Annotate documents with =org-mode=.
#+BEGIN_SRC emacs-lisp
(use-package org-noter)
#+END_SRC

**** org-preview-html
Preview org-file in an =eww= buffer.
#+BEGIN_SRC emacs-lisp
(use-package org-preview-html)
#+END_SRC

**** org-radiobutton
Support for radiobuttons.
#+BEGIN_SRC emacs-lisp
(use-package org-radiobutton
  :hook
  (org-mode . org-radiobutton-mode))
#+END_SRC

**** org-tree-slide
Presentation mode.
#+BEGIN_SRC emacs-lisp
(use-package org-tree-slide
  :hook
  (org-tree-slide-play . turn-on-hide-mode-line-mode)
  (org-tree-slide-stop . turn-off-hide-mode-line-mode)
  (org-tree-slide-play . no-fringes)
  (org-tree-slide-stop . restore-fringes)
  :custom
  (org-tree-slide-header nil)
  (org-tree-slide-slide-in-effect nil)
  :general
  (:keymaps
   'org-tree-slide-mode-map
   "<right>" 'org-tree-slide-move-next-tree
   "<left>" 'org-tree-slide-move-previous-tree)
  (:keymaps
   'org-mode-map
   :prefix init-local-leader-key
   "p" 'org-tree-slide-mode))
#+END_SRC

**** ob-http
#+BEGIN_SRC emacs-lisp
(use-package ob-http
  :init
  (cl-pushnew '(http . t) org-babel-load-languages :test #'equal))
#+END_SRC

*** Appearance
This sections makes =org-mode= look more beautiful and appealing.

#+BEGIN_SRC emacs-lisp
(use-package org
  :hook
  (org-babel-after-execute . org-redisplay-inline-images)
  (org-mode . init-org-prettify-syntax)
  :custom
  (org-fontify-quote-and-verse-blocks t)
  (org-hide-emphasis-markers t)
  (org-pretty-entities t)
  (org-src-fontify-natively t)
  (org-startup-indented t)
  (org-startup-with-inline-images t)
  :preface
  (defun init-org-prettify-syntax ()
    "Prettify syntax with symbols."
    (dolist (symbol '(("#+title:" . ?⋮)
                      ("#+TITLE:" . ?⋮)
                      ("#+subtitle:" . ?⋮)
                      ("#+SUBTITLE:" . ?⋮)
                      ("#+begin_src" . ?λ)
                      ("#+BEGIN_SRC" . ?λ)
                      ("#+end_src" . ?≋)
                      ("#+END_SRC" . ?≋)
                      ("#+begin_quote" . ?“)
                      ("#+BEGIN_QUOTE" . ?“)
                      ("#+end_quote" . ?”)
                      ("#+END_QUOTE" . ?”)))
      (cl-pushnew symbol prettify-symbols-alist :test #'equal))
    (dolist (n (number-sequence 1 8 1))
      (let ((symbol (cons (concat (make-string n ?*) " ") (-interpose '(Br . Bl) (make-list (+ 1 n) ?\s)))))
        (cl-pushnew symbol prettify-symbols-alist :test #'equal)))
    (prettify-symbols-mode 1)))
#+END_SRC

**** Emphasis
Allow more newlines (1 to 4) for emphasized text, useful when filling long text.
#+BEGIN_SRC emacs-lisp
(use-package org
  :config
  (setcar (nthcdr 4 org-emphasis-regexp-components) 4)
  (org-set-emph-re 'org-emphasis-regexp-components org-emphasis-regexp-components))
#+END_SRC

**** Variable pitch
Use variable-pitch font but still make sure everything aligns.
#+BEGIN_SRC emacs-lisp
(use-package org-variable-pitch
  :hook (org-mode . org-variable-pitch-minor-mode)
  :custom
  (org-variable-pitch-fixed-font init-fixed-pitch-font)
  (org-variable-pitch-fontify-headline-prefix t))
#+END_SRC

**** Headings
#+BEGIN_SRC emacs-lisp
(use-package org
  :custom
  (org-ellipsis "  ")
  (org-fontify-whole-heading-line t)
  (org-fontify-todo-headline t)
  (org-fontify-done-headline t))
#+END_SRC

**** Bullet lists
#+BEGIN_SRC emacs-lisp
(font-lock-add-keywords
 'org-mode
 '(("^ +\\([-*+]\\) "
    (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "●"))))
   ("^ *[-*+] \\[\\(X\\)\\] "
    (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "✕"))))))
#+END_SRC

**** Task lists
Use symbols to represent task state.
#+BEGIN_SRC emacs-lisp
(defun init-org-prettify-task-symbols ()
  "Prettify task list symbols."
  (dolist (symbol '(("TODO"     . ?⚑)
                    ("DOING"    . ?⚐)
                    ("CANCELED" . ?✘)
                    ("DONE"     . ?✔)))
    (cl-pushnew symbol prettify-symbols-alist :test #'equal)))
(add-hook 'org-mode-hook #'init-org-prettify-task-symbols)
#+END_SRC

**** Breadcrumbs
Remove style from heading breadcrumbs.
#+BEGIN_SRC emacs-lisp
(defun +org-eldoc-get-breadcrumb-no-properties (string)
  "Remove properties from STRING."
  (when string (substring-no-properties string)))
(advice-add 'org-eldoc-get-breadcrumb :filter-return #'+org-eldoc-get-breadcrumb-no-properties)
#+END_SRC

**** Tables
#+BEGIN_SRC emacs-lisp
(use-package org-pretty-table
  :hook
  (org-mode . org-pretty-table-mode))
#+END_SRC

*** Export
**** LaTeX
Disable link colors.
#+BEGIN_SRC emacs-lisp
(use-package ox-latex
  :custom
  (org-latex-hyperref-template
   (mapconcat
    'identity
    '("\\hypersetup{"
      "pdfauthor={%a},"
      "pdftitle={%t},"
      "pdfkeywords={%k},"
      "pdfsubject={%d},"
      "pdfcreator={%c},"
      "pdflang={%L},"
      "pdfborder=0 0 0}")
    "\n")))
#+END_SRC

Add links in footnotes.
#+BEGIN_SRC emacs-lisp
(defvar org-export-latex-add-link-footnotes t
  "If non-nil links will be added as footnotes if exported to latex.")

(defun +org-export-latex-link-footnote (text backend _info)
  "Create a footnote in latex for each link. So when printed the information isn't lost.
If there is a URL and the export BACKEND is latex, then extract
URL into footnote from TEXT."
  (when (and org-export-latex-add-link-footnotes
             (org-export-derived-backend-p backend 'latex)
             (string-match "\\\\href{\\(.*\\)}{\\(.*\\)}" text))
    (when (cl-some (lambda (type)
                     (string-prefix-p type (match-string 1 text)))
                   '("http" "https" "ftp" "mailto" "doi"))
      (format "%s \\footnote{\\url{%s}} " text (match-string 1 text)))))

(with-eval-after-load 'ox
  (cl-pushnew #'+org-export-latex-link-footnote org-export-filter-link-functions :test #'equal))
#+END_SRC

** ansible
#+BEGIN_SRC emacs-lisp
(use-package ansible
  :minor
  "site\\.yml\\'"
  "roles/.+\\.yml\\'"
  :magic-minor
  "^\\(---\n\\)?\\(#.*\n\\)* *-? \\(environment\\|h\\(?:\\(?:andler\\|ost\\)s\\)\\|i\\(?:mport_tasks\\|nclude\\(?:_tasks\\)?\\)\\|p\\(?:\\(?:ost\\|re\\)_tasks\\)\\|roles?\\|tasks\\|vars\\(?:_\\(?:files\\|prompt\\)\\)?\\):")

(use-package ansible-doc
  :hook (ansible . ansible-doc-mode)
  :preface
  (defun ansible-doc-at-point ()
    "Ansible doc with selected point"
    (interactive)
    (ansible-doc (thing-at-point 'symbol)))
  :general
  (:keymaps
   'ansible::key-map
   "M-g k" 'ansible-doc-at-point))
#+END_SRC

** clojure
#+BEGIN_SRC emacs-lisp
(use-package clojure-mode
  :mode
  "\\.\\(clj\\|dtm\\|edn\\)\\'"
  "\\(?:build\\|profile\\)\\.boot\\'"
  ("\\.cljc\\'" . clojurec-mode)
  ("\\.cljs\\'" . clojurescript-mode))
#+END_SRC

*** Packages
**** cider
#+BEGIN_SRC emacs-lisp
(use-package cider
  :hook
  (cider-mode . cider-auto-test-mode)
  :custom
  (cider-prompt-for-symbol nil)
  (cider-repl-display-help-banner nil)
  (cider-repl-history-file (concat init-data-dir "cider-history"))
  (org-babel-clojure-backend 'cider)
  :general
  (:keymaps
   'cider-mode-map
   :prefix init-local-leader-key
   "c" 'cider-refresh
   "t" 'cider-test-run-test
   "T" 'cider-test-run-ns-tests
   "s" 'cider-test-run-project-tests))
#+END_SRC

** crystal
#+BEGIN_SRC emacs-lisp
(use-package crystal-mode
  :mode "\\(?:\\.cr\\)\\'"
  :general
  (:keymaps
   'crystal-mode-map
   :prefix init-local-leader-key
   "t" 'crystal-spec-line
   "T" 'crystal-spec-buffer
   "s" 'crystal-spec-all))
#+END_SRC

*** Packages
**** inf-crystal
#+BEGIN_SRC emacs-lisp
(use-package inf-crystal
  :hook
  (crystal-mode . inf-crystal-minor-mode)
  :general
  (:keymaps
   'crystal-mode-map
   :prefix init-local-leader-key
   "r" 'inf-crystal))
#+END_SRC

** csv
#+BEGIN_SRC emacs-lisp
(use-package csv-mode
  :mode
  "\\.[Cc][Ss][Vv]\\'"
  ("\\.tsv\\'" . tsv-mode)
  :custom
  (csv-separators '("," "\t" ";")))
#+END_SRC

** elasticsearch
#+BEGIN_SRC emacs-lisp
(use-package es-mode
  :mode "\\.es\\'")
#+END_SRC

** elixir
#+BEGIN_SRC emacs-lisp
(use-package elixir-mode
  :mode
  "\\.elixir\\'"
  "\\.ex\\'"
  "\\.exs\\'")
#+END_SRC

*** Packages
**** alchemist
#+BEGIN_SRC emacs-lisp
(use-package alchemist
  :hook
  (elixir-mode . alchemist-mode)
  :general
  (:keymaps
   'alchemist-mode-map
   "M-g k" 'alchemist-help-search-at-point)
  (:keymaps
   'alchemist-mode-map
   :prefix init-local-leader-key
   "r" 'alchemist-iex-run
   "s" 'alchemist-mix-test
   "t" 'alchemist-mix-test-at-point
   "T" 'alchemist-mix-test-this-buffer))
#+END_SRC

** elm
#+BEGIN_SRC emacs-lisp
(use-package elm-mode
  :mode "\\.elm\\'"
  :custom
  (elm-format-on-save t)
  (elm-package-json "elm.json")
  (elm-tags-exclude-elm-stuff nil)
  (elm-tags-on-save t)
  :general
  (:keymaps
   'elm-mode-map
   :prefix init-local-leader-key
   "t" 'elm-test-project))
#+END_SRC

** epub
*** Packages
**** nov
#+BEGIN_SRC emacs-lisp
(use-package nov
  :mode
  ("\\.epub\\'" . nov-mode)
  :hook
  (nov-mode . init-nov-delayed-render)
  (nov-mode . init-nov-fringes)
  :custom
  (nov-save-place-file (concat init-data-dir "nov-places"))
  :preface
  (defun init-nov-delayed-render ()
    (run-with-idle-timer 0.2 nil 'nov-render-document))

  (defun init-nov-fringes ()
    "Hide the fringes for `nov-mode'."
    (set-window-fringes (get-buffer-window) 0 0 nil)))
#+END_SRC

** erlang
#+BEGIN_SRC emacs-lisp
(use-package erlang
  :mode
  "\\.erl$"
  "\\.app\\.src$"
  "\\.escript"
  "\\.hrl$"
  "\\.xrl$"
  "\\.yrl"
  "/ebin/.+\\.app"
  :hook
  (erlang-mode . init-erlang-eunit)
  (erlang-mode . init-erlang-flymake)
  :general
  (:keymaps
   'erlang-mode-map
   "M-g k" 'erlang-man-function)
  (:keymaps
   'erlang-mode-map
   :prefix init-local-leader-key
   "t" 'erlang-eunit-compile-and-run-current-test
   "T" 'erlang-eunit-compile-and-run-module-tests
   "r" 'erlang-shell-display)
  :preface
  (defun init-erlang-eunit ()
    "Setup EUnit support for `erlang-mode'."
    (require 'erlang-eunit))
  (defun init-erlang-flymake ()
    "Setup `flymake' support for `erlang-mode'."
    (require 'erlang-flymake)
    (flymake-mode 1)))
#+END_SRC

*** Packages
**** ivy-erlang-complete
#+BEGIN_SRC emacs-lisp
(use-package ivy-erlang-complete
  :hook
  (erlang-mode . ivy-erlang-complete-init)
  (erlang-mode . init-erlang-ivy-completion)
  :preface
  (defun init-erlang-ivy-completion ()
    "Setup completion via `ivy' for `erlang-mode'."
    (add-hook 'after-save-hook #'ivy-erlang-complete-reparse nil t)))
#+END_SRC

** git
*** Packages
**** gitignore-mode
#+BEGIN_SRC emacs-lisp
(use-package gitignore-mode
  :mode "/\\.dockerignore\\'")
#+END_SRC

** go
#+BEGIN_SRC emacs-lisp
(use-package go-mode
  :mode
  "\\.go\\'"
  ("go\\.mod\\'" . go-dot-mod-mode)
  :hook
  (go-mode . init-go-prettify-symbols)
  :custom
  (gofmt-command "goimports")
  :general
  (:keymaps
   'go-mode-map
   "M-g k" 'godoc-at-point)
  :preface
  (defun init-go-prettify-symbols ()
    (dolist (symbol '(("funct"  . ?ƒ)))
      (cl-pushnew symbol prettify-symbols-alist :test #'equal))))
#+END_SRC

*** Packages
**** go-eldoc
#+BEGIN_SRC emacs-lisp
(use-package go-eldoc
  :hook
  (go-mode . go-eldoc-setup))
#+END_SRC

**** gorepl-mode
#+BEGIN_SRC emacs-lisp
(use-package gorepl-mode
  :hook
  (go-mode . gorepl-mode))
#+END_SRC

** groovy
#+BEGIN_SRC emacs-lisp
(use-package groovy-mode
  :mode
  "\\.g\\(?:ant\\|roovy\\|radle\\)\\'"
  "Jenkinsfile")
#+END_SRC

** fish
#+BEGIN_SRC emacs-lisp
(use-package fish-mode
  :mode
  "\\.fish\\'"
  "/fish_funced\\..*\\'")
#+END_SRC

** haskell
#+BEGIN_SRC emacs-lisp
(use-package haskell-mode
  :mode
  "\\.[gh]s\\'"
  "\\.hsig\\'"
  "\\.hsc\\'"
  ("\\.cabal\\'\\|/cabal\\.project\\|/\\.cabal/config\\'" . haskell-cabal-mode)
  ("\\.l[gh]s\\'" . haskell-literate-mode)
  :hook
  (haskell-mode . interactive-haskell-mode)
  :custom
  (haskell-font-lock-symbols t)
  (haskell-process-auto-import-loaded-modules t)
  (haskell-process-log t)
  (haskell-process-show-debug-tips nil)
  (haskell-process-use-presentation-mode t)
  (haskell-stylish-on-save t)
  (haskell-mode-stylish-haskell-path "brittany")
  :general
  (:keymaps
   'interactive-haskell-mode-map
   "M-." 'nil)
  (:keymaps
   'haskell-mode-map
   :prefix init-local-leader-key
   "r" 'haskell-interactive-switch
   "R" 'haskell-session-change-target)
  :init
  ;; Allow configuring project local cabal repl commands.
  (put 'haskell-process-args-cabal-repl 'safe-local-variable (lambda (x) (seq-every-p #'stringp x))))
#+END_SRC

*** REPL
Persist REPL history.
#+BEGIN_SRC emacs-lisp
(use-package haskell-mode
  :hook
  (haskell-interactive-mode . +haskell-interactive-load-history)
  :defines (haskell-interactive-mode-history)
  :preface
  (defvar +haskell-interactive-global-history nil)

  (defun +haskell-interactive-save-history ()
    "Save `haskell-interactive-mode' history."
    (setq +haskell-interactive-global-history haskell-interactive-mode-history))

  (defun +haskell-interactive-load-history ()
    "Restore `haskell-interactive-mode' history."
    (add-hook 'kill-buffer-hook #'+haskell-interactive-save-history nil t)
    (when +haskell-interactive-global-history
      (setq haskell-interactive-mode-history +haskell-interactive-global-history)))
  :config
  (cl-pushnew '+haskell-interactive-global-history savehist-additional-variables :test #'equal))
#+END_SRC

*** Packages
**** hasky-stack
#+BEGIN_SRC emacs-lisp
(use-package hasky-stack
  :general
  (:keymaps
   'haskell-mode-map
   :prefix init-local-leader-key
   "t" 'hasky-stack-test))
#+END_SRC

** java
*** Packages
**** gradle-mode
#+BEGIN_SRC emacs-lisp
(use-package gradle-mode
  :hook
  ((java-mode kotlin-mode) . gradle-mode)
  :general
  (:keymaps
   'gradle-mode-map
   :prefix init-local-leader-key
   "t" 'gradle-test))
#+END_SRC

**** java-lookup
#+BEGIN_SRC emacs-lisp
(use-package javadoc-lookup
  :general
  (:keymaps
   'java-mode-map
   "M-g k" 'javadoc-lookup))
#+END_SRC

** js
#+BEGIN_SRC emacs-lisp
(use-package js
  :mode
  ("\\.js[mx]?\\'" . javascript-mode)
  ("\\.har\\'" . javascript-mode)
  :hook
  (js-mode . init-js-find-file)
  (js-mode . init-js-prettify-symbols)
  :preface
  (defun init-js-find-file ()
    "Setup `ff-test-find-other-file' support for `js-mode'."
    (setq ff-test-search-implementation-project-directories '("src")
          ff-test-search-test-directories '("." "__tests__")
          ff-test-search-test-project-directories '("test" "spec" "__tests__")))

  (defun init-js-prettify-symbols ()
    (dolist (symbol '(("=="        . ?≈)
                      ("!="        . "≈/")
                      ("=>"        . (?- (Br . Bc) ?- (Br . Bc) ?>))
                      ("function"  . ?ƒ)
                      ("let"       . ?ν)
                      ("const"     . "ν_")
                      ("undefined" . ?∅)
                      ("Infinity"  . ?∞)))
      (cl-pushnew symbol prettify-symbols-alist :test #'equal))))
#+END_SRC

*** Packages
**** flymake-eslint
#+BEGIN_SRC emacs-lisp
(use-package flymake-eslint
  :init
  (put 'flymake-eslint-executable-name 'safe-local-variable #'(lambda (x) (member x '("eslint" "eslint_d"))))
  (put 'flymake-eslint-executable-args 'safe-local-variable 'stringp))
#+END_SRC

**** indium
Debugger
#+BEGIN_SRC emacs-lisp
(use-package indium
  :hook
  (js-mode . +indium-interaction-unless-json-mode)
  :commands
  (indium-interaction-mode)
  :preface
  (defun +indium-interaction-unless-json-mode ()
    (unless (derived-mode-p 'json-mode) (indium-interaction-mode)))
  :general
  (:keymaps
   'js-mode-map
   :prefix init-local-leader-key
   "s" 'indium-scratch
   "o" 'indium-launch
   "O" 'indium-connect)
  (:keymaps
   'indium-debugger-mode
   :definer 'minor-mode
   "RET" 'indium-debugger-step-over))
#+END_SRC

**** jest
Test framework execution.
#+BEGIN_SRC emacs-lisp
(use-package jest
  :general
  (:keymaps
   'js-mode-map
   :prefix init-local-leader-key
   "t" 'jest-funcion-dwim
   "T" 'jest-file
   "s" 'jest-popup))
#+END_SRC

**** js2
#+BEGIN_SRC emacs-lisp
(use-package js2-mode
  :hook
  (js-mode . js2-minor-mode)
  :custom
  (js2-highlight-external-variables nil)
  (js2-mode-show-parse-errors nil)
  (js2-skip-preprocessor-directives t)
  (js2-strict-missing-semi-warning nil)
  (js2-strict-trailing-comma-warning nil))
#+END_SRC

**** js2-refactor
Refactor utils, also a dependecy for =indium= debugger.
#+BEGIN_SRC emacs-lisp
(use-package js2-refactor
  :hook
  (js2-minor-mode . js2-refactor-mode))
#+END_SRC

**** nodejs-repl
REPL for nodejs.
#+BEGIN_SRC emacs-lisp
(use-package nodejs-repl)
#+END_SRC

** json
#+BEGIN_SRC emacs-lisp
(use-package json-mode
  :mode
  "\\(?:\\(?:\\.json\\|\\.jsonld\\|\\.babelrc\\|\\.bowerrc\\|composer\\.lock\\)\\'\\)"
  :preface
  (defun init-json-mode-flymake ()
    "Setup `json-mode' integration with Flymake."
    (add-hook 'flymake-diagnostic-functions #'flymake-check-jsonlint nil t)
    (flymake-mode))
  :hook
  (json-mode . init-json-mode-flymake))
#+END_SRC

*** Syntax checker
#+BEGIN_SRC emacs-lisp
(flymake-quickdef-backend flymake-check-jsonlint
  :pre-let ((jsonlint-exec (executable-find "jsonlint")))
  :pre-check (unless jsonlint-exec (error "Cannot find jsonlint executable"))
  :write-type 'file
  :proc-form (list jsonlint-exec "-c" "-q" fmqd-temp-file)
  :search-regexp "^\\(.+\\)\: line \\([0-9]+\\), col \\([0-9]+\\), \\(.+\\)$"
  :prep-diagnostic
  (let* ((lnum (string-to-number (match-string 2)))
         (col (string-to-number (match-string 3)))
         (msg (match-string 4))
         (pos (flymake-diag-region fmqd-source lnum col))
         (beg (car pos))
         (end (cdr pos))
         (type :error))
    (list fmqd-source beg end type msg)))
#+END_SRC

*** Packages
**** json-navigator
#+BEGIN_SRC emacs-lisp
(use-package json-navigator
  :general
  (:keymaps
   'json-mode-map
   :prefix init-local-leader-key
   "n" 'json-navigator-navigate-region))
#+END_SRC

** jsx
React JSX support.
#+BEGIN_SRC emacs-lisp
(use-package rjsx-mode
  :mode "\\.jsx\\'"
  :magic
  ("\\(import.*from \'react\';?\\|\/\/ @flow\nimport.*from \'react\';?\\)" . rjsx-mode)
  :general
  (:keymaps
   'rjsx-mode-map
   :prefix init-local-leader-key
   "R" 'rjsx-rename-tag-at-point))
#+END_SRC

** kotlin
#+BEGIN_SRC emacs-lisp
(use-package kotlin-mode)
#+END_SRC

** lisp
*** Packages
**** slime
#+BEGIN_SRC emacs-lisp
(use-package slime
  :hook
  (lisp-mode . slime-mode)
  :custom
  (inferior-lisp-program "sbcl")
  (slime-contribs '(slime-fancy slime-repl))
  :general
  (:keymaps
   'slime-mode-map
   "M-g k" 'slime-describe-symbol)
  (:keymaps
   'slime-mode-map
   :prefix init-local-leader-key
   "o" 'slime
   "t" 'slime-load-file-and-other-file)
  :preface
  (defun slime-load-file-and-other-file ()
    "Load buffer file and then load other (test) file."
    (interactive)
    (dolist (file `(,buffer-file-name ,(ff-test-other-file-name)))
      (when (and file (file-exists-p file))
        (slime-load-file file)))))
#+END_SRC

** lua
#+BEGIN_SRC emacs-lisp
(use-package lua-mode
  :mode "\\.lua\\'"
  :hook
  (lua-mode . init-lua-prettify-symbols)
  :custom
  (lua-documentation-function 'eww)
  :general
  (:keymaps
   'lua-mode-map
   "M-g k" 'lua-search-documentation)
  :preface
  (defun init-lua-prettify-symbols ()
    (dolist (symbol '(("~="  . (?\s (Br . Bl) ?\s (Bc . Bc) ?≠))
                      ("function"  . ?ƒ)
                      ("math.huge" . ?∞)))
      (cl-pushnew symbol prettify-symbols-alist :test #'equal))))
#+END_SRC

** markdown
#+BEGIN_SRC emacs-lisp
(use-package markdown-mode
  :mode
  "\\.markdown\\'"
  "\\.md\\'"
  :hook
  (markdown-mode . auto-fill-mode)
  :custom
  (markdown-enable-wiki-links t)
  (markdown-fontify-code-blocks-natively t)
  (markdown-header-scaling t)
  (markdown-hide-markup t)
  (markdown-italic-underscore t)
  (markdown-make-gfm-checkboxes-buttons t)
  :general
  (:keymaps
   'markdown-mode-map
   :prefix init-local-leader-key
   "v" 'markdown-toggle-markup-hiding))
#+END_SRC

*** Packages
**** edit-indirect
Editing regions in separate buffers.
#+BEGIN_SRC emacs-lisp
(use-package edit-indirect)
#+END_SRC

**** markdown-toc
Generate Table of Contents.
#+BEGIN_SRC emacs-lisp
(use-package markdown-toc)
#+END_SRC

*** Appearance
**** Variable pitch
Use variable-pitch font but still make sure everything aligns.
#+BEGIN_SRC emacs-lisp
(font-lock-add-keywords
 'markdown-mode
 '(("^[[:space:]-*+>]+" 0 'fixed-pitch append))
 'append)
#+END_SRC

**** Bullet lists
Pretty check-boxes
#+BEGIN_SRC emacs-lisp
(font-lock-add-keywords
 'markdown-mode
 '(("^ *[-*+] \\[\\([Xx]\\)\\] "
    (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "✕"))))))
#+END_SRC

** nginx
#+BEGIN_SRC emacs-lisp
(use-package nginx-mode
  :mode
  "/nginx/.+\\.conf\\'"
  "nginx\\.conf\\'")
#+END_SRC

** nix
#+BEGIN_SRC emacs-lisp
(use-package nix-mode
  :mode "\\.nix\\'")
#+END_SRC

*** Packages
**** nix-update
#+BEGIN_SRC emacs-lisp
(use-package nix-update
  :general
  (:keymaps
   'nix-mode-map
   :prefix init-local-leader-key
   "u" 'nix-update-fetch))
#+END_SRC

** nxml
#+BEGIN_SRC emacs-lisp
(use-package nxml-mode
  :mode "\\.plist\\'"
  :custom
  (nxml-slash-auto-complete-flag t)
  :config
  (with-eval-after-load 'smartparens
    (sp-local-pair '(nxml-mode) "<" ">" :actions :rem)))
#+END_SRC

** ocaml
#+BEGIN_SRC emacs-lisp
(use-package caml)

(use-package tuareg
  :general
  (:keymaps
   'tuareg-mode-map
   "C-x C-e" 'tuareg-eval-phrase)
  (:keymaps
   'tuareg-mode-map
   :prefix init-local-leader-key
   "r" 'run-ocaml))
#+END_SRC

** pdf
*** Packages
**** pdf-tools
#+BEGIN_SRC emacs-lisp
(use-package pdf-tools
  :mode ("\\.pdf\\'" . pdf-view-mode))
#+END_SRC

** plantuml
#+BEGIN_SRC emacs-lisp
(use-package plantuml-mode
  :mode "\\.\\(plantuml\\|pum\\|plu\\)\\'"
  :custom
  (plantuml-default-exec-mode 'executable))
#+END_SRC

** protobuf
#+BEGIN_SRC emacs-lisp
(use-package protobuf-mode
  :mode "\\.proto\\'")
#+END_SRC

** python
#+BEGIN_SRC emacs-lisp
(use-package python
  :hook
  (python-mode . init-python-prettify-symbols)
  :general
  (:keymaps
   'python-mode-map
   :prefix init-local-leader-key
   "r" 'run-python)
  :preface
  (defun init-python-prettify-symbols ()
    (dolist (symbol '(("def"      . ?ƒ)
                      ("sum"      . ?Σ)
                      ("not"      . ?￢)
                      ("in"       . ?∈)
                      ("for"      . ?∀)
                      ("**2"      . ?²)
                      ("**3"      . ?³)
                      ("None"     . ?∅)
                      ("math.inf" . ?∞)))
      (cl-pushnew symbol prettify-symbols-alist :test #'equal)))
  :config
  (put 'python-shell-interpreter 'safe-local-variable #'(lambda (x) (member x '("python" "ipython")))))
#+END_SRC

*** Packages
**** pip-requirements
Editing pip requirements files.
#+BEGIN_SRC emacs-lisp
(use-package pip-requirements)
#+END_SRC

**** pydoc
#+BEGIN_SRC emacs-lisp
(use-package pydoc
  :general
  (:keymaps
   'python-mode-map
   "M-g k" 'pydoc-at-point))
#+END_SRC

**** python-test
#+BEGIN_SRC emacs-lisp
(use-package python-test
  :custom
  (python-test-backend 'pytest)
  :general
  (:keymaps
   'python-mode-map
   :prefix init-local-leader-key
   "t" 'python-test-project)
  :config
  (setq python-test-project-root-files
        (append '("README.md") python-test-project-root-files)))
#+END_SRC

** racket
#+BEGIN_SRC emacs-lisp
(use-package racket-mode
  :mode "\\.rkt[dl]?\\'"
  :general
  (:keymaps
   'racket-mode-map
   "M-g k" 'racket-doc)
  (:keymaps
   'racket-mode-map
   :prefix init-local-leader-key
   "t" 'racket-test))
#+END_SRC

*** Packages
**** flymake-racket
#+BEGIN_SRC emacs-lisp
(use-package flymake-racket
  :hook
  (racket-mode . flymake-racket-add-hook))
#+END_SRC

** rst
#+BEGIN_SRC emacs-lisp
(use-package rst
  :hook
  (rst-mode . auto-fill-mode)
  :preface
  (defvar rst-adornment-regexp nil
    "Regular expression to match adornments.")
  :config
  (setq rst-adornment-regexp
        (concat "^[" rst-adornment-chars "]\\{3,\\}$")))
#+END_SRC

*** Appearance
**** Variable pitch
Use variable-pitch font but still make sure everything aligns.
#+BEGIN_SRC emacs-lisp
(font-lock-add-keywords
 'rst-mode
 '(("^[[:space:]-*+]+\\(\\[.\\]\\)?" 0 'fixed-pitch append))
 'append)
#+END_SRC

**** Heading
Hide heading adornments.
#+BEGIN_SRC emacs-lisp
(defun +rst-hide-heading-adornment ()
  "Hide heading adornment for `rst-mode'."
  (interactive)
  (hide-lines-matching rst-adornment-regexp))
(add-hook 'rst-mode-hook #'+rst-hide-heading-adornment)
#+END_SRC

**** Bullet lists
Pretty check-boxes as well as bullet lists.
#+BEGIN_SRC emacs-lisp
(font-lock-add-keywords
 'rst-mode
 '(("^ *\\([-*+]\\) "
    (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "●"))))
   ("^ *[-*+] \\[\\([Xx]\\)\\] "
    (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "✕"))))))
#+END_SRC

** ruby
#+BEGIN_SRC emacs-lisp
(use-package ruby-mode
  :hook
  (ruby-mode . init-ruby-find-file)
  (ruby-mode . init-ruby-prettify-symbols)
  :custom
  (ruby-align-chained-calls t)
  :preface
  (defun init-ruby-find-file ()
    "Setup `ff-test-find-other-file' support for `ruby-mode'."
    (setq ff-test-suffixes '("_test" "_spec")
          ff-test-search-implementation-project-directories '("app" "lib")
          ff-test-search-test-project-directories '("test" "spec")))

  (defun init-ruby-prettify-symbols ()
    (dolist (symbol '(("def"             . ?ƒ)
                      ("Float::INFINITY" . ?∞)))
      (cl-pushnew symbol prettify-symbols-alist :test #'equal)))
  :config
  (with-eval-after-load 'hideshow
    (cl-pushnew `(ruby-mode
                  ,(rx (or "def" "class" "module" "do" "{" "[")) ; Block start
                  ,(rx (or "}" "]" "end"))                       ; Block end
                  ,(rx bol
                       (or (+ (zero-or-more blank) "#") "=begin")) ; Comment start
                  ruby-forward-sexp nil)
                hs-special-modes-alist
                :test #'equal)))
#+END_SRC

*** Testing
#+BEGIN_SRC emacs-lisp
(defun ruby-test-all ()
  "Test all files using either RSpec or MiniTest."
  (interactive)
  (if (bound-and-true-p rspec-mode)
      (rspec-verify-all)
    (minitest-verify-all)))

(defun ruby-test-file ()
  "Test current file using either RSpec or MiniTest."
  (interactive)
  (if (bound-and-true-p rspec-mode)
      (rspec-verify)
    (minitest-verify)))

(defun ruby-test-at-point ()
  "Test definition at point using either RSpec or MiniTest."
  (interactive)
  (if (bound-and-true-p rspec-mode)
      (rspec-verify-single)
    (minitest-verify-single)))

(general-define-key
 :keymaps 'ruby-mode-map
 :prefix init-local-leader-key
 "t" 'ruby-test-at-point
 "T" 'ruby-test-file
 "s" 'ruby-test-all)
#+END_SRC

*** Packages
**** inf-ruby
#+BEGIN_SRC emacs-lisp
(use-package inf-ruby
  :hook
  (ruby-mode . inf-ruby-minor-mode)
  ;; Auto breakpoint
  (compilation-filter . inf-ruby-auto-enter)
  :custom
  (inf-ruby-default-implementation "pry")
  :general
  (:keymaps
   'ruby-mode-map
   :prefix init-local-leader-key
   "r" 'inf-ruby))
#+END_SRC

**** minitest
#+BEGIN_SRC emacs-lisp
(use-package minitest
  :hook
  (ruby-mode . minitest-enable-appropriate-mode))
#+END_SRC

**** rake
#+BEGIN_SRC emacs-lisp
(use-package rake
  :custom
  (rake-completion-system 'default)
  (rake-cache-file (expand-file-name "rake.cache" init-cache-dir)))
#+END_SRC

**** rspec-mode
#+BEGIN_SRC emacs-lisp
(use-package rspec-mode
  :hook
  (ruby-mode . rspec-enable-appropriate-mode)
  :custom
  (rspec-use-relative-path t)
  (rspec-use-opts-file-when-available nil)
  (rspec-command-options "--format progress"))
#+END_SRC

**** ruby-refactor
#+BEGIN_SRC emacs-lisp
(use-package ruby-refactor
  :hook
  (ruby-mode . ruby-refactor-mode))
#+END_SRC

**** yard-mode
#+BEGIN_SRC emacs-lisp
(use-package yard-mode
  :hook ruby-mode)
#+END_SRC

**** yari
#+BEGIN_SRC emacs-lisp
(use-package yari
  :general
  (:keymaps
   'ruby-mode-map
   "M-g k" 'yari)
  (:keymaps
   'help-command-map
   "R" 'yari))
#+END_SRC

** rust
#+BEGIN_SRC emacs-lisp
(use-package rustic
  :mode
  ("\\.rs\\'" . rustic-mode)
  :custom
  (rustic-rls-pkg 'eglot)
  :general
  (:keymaps
   'rustic-mode-map
   :prefix init-local-leader-key
   "t" 'rustic-cargo-test)
  :init
  (with-eval-after-load 'org
    (cl-pushnew '("rust" . rustic) org-src-lang-modes :test #'equal))
  :config
  (require 'eglot))
#+END_SRC

** salt
#+BEGIN_SRC emacs-lisp
(use-package salt-mode
  :mode "\\.sls\\'"
  :general
  (:keymaps
   'salt-mode-map
   "M-g k" 'salt-mode-browse-doc))
#+END_SRC

** scala
#+BEGIN_SRC emacs-lisp
(use-package scala-mode
  :mode "\\.\\(scala\\|sbt\\)\\'"
  :hook
  (scala-mode . init-scala-prettify-symbols)
  :custom
  (scala-indent:align-parameters t)
  :preface
  (defun init-scala-prettify-symbols ()
    (setq prettify-symbols-alist scala-prettify-symbols-alist)))
#+END_SRC

*** Packages
**** sbt-mode
#+BEGIN_SRC emacs-lisp
(use-package sbt-mode)
#+END_SRC

** sh
#+BEGIN_SRC emacs-lisp
(use-package sh-script
  :custom
  ;; Use regular indentation for line-continuation
  (sh-indent-after-continuation 'always)
  :general
  (:keymaps
   'sh-mode-map
   "M-g k" 'man))
#+END_SRC

*** Packages
**** flymake-shellcheck
#+BEGIN_SRC emacs-lisp
(use-package flymake-shellcheck
  :hook
  (sh-mode . flymake-mode)
  (sh-mode . flymake-shellcheck-load))
#+END_SRC

** sql
#+BEGIN_SRC emacs-lisp
(use-package sql
  :custom
  (sql-mysql-options '("--protocol=tcp" "--prompt=" "--disable-pager")))
#+END_SRC

** term
#+BEGIN_SRC emacs-lisp
(use-package term
  :custom
  (explicit-shell-file-name "fish")
  :general
  (:prefix
   init-launch-prefix
   "T" 'term))
#+END_SRC

** typescript
#+BEGIN_SRC emacs-lisp
(use-package typescript-mode
  :mode "\\.ts$"
  :hook
  (typescript-mode . init-typescript-find-file)
  (typescript-mode . init-typescript-prettify-symbols)
  :general
  (:keymaps
   'typescript-mode-map
   "C-c '" 'nil)
  :preface
  (defun init-typescript-find-file ()
    "Setup `ff-test-find-other-file' support for `typescript-mode'."
    (setq ff-test-search-implementation-project-directories '("src")
          ff-test-search-test-directories '("." "__tests__")
          ff-test-search-test-project-directories '("test" "spec" "__tests__")))

  (defun init-typescript-prettify-symbols ()
    (dolist (symbol '(("=="        . ?≈)
                      ("!="        . "≈/")
                      ("=>"        . (?- (Br . Bc) ?- (Br . Bc) ?>))
                      ("function"  . ?ƒ)
                      ("let"       . ?ν)
                      ("const"     . "ν_")
                      ("null"      . ?∅)
                      ("Infinity"  . ?∞)))
      (cl-pushnew symbol prettify-symbols-alist :test #'equal))))
#+END_SRC

*** Packages
**** ts-comint
TypeScript REPL.
#+BEGIN_SRC emacs-lisp
(use-package ts-comint
  :custom
  (ts-comint-program-command "ts-node"))
#+END_SRC

**** jest
Test framework execution.
#+BEGIN_SRC emacs-lisp
(use-package jest
  :general
  (:keymaps
   'typescript-mode-map
   :prefix init-local-leader-key
   "t" 'jest-function-dwim
   "T" 'jest-file
   "s" 'jest-popup))
#+END_SRC

** web
*** Packages
**** cakecrumbs
Display current path for HTML/XML/CSS.
#+BEGIN_SRC emacs-lisp
(use-package cakecrumbs
  :functions
  (cakecrumbs-auto-setup)
  :config
  (cakecrumbs-auto-setup))
#+END_SRC

**** emmet-mode
Snippets and Zen Coding for HTML.
#+BEGIN_SRC emacs-lisp
(use-package emmet-mode
  :hook
  (css-mode
   haml-mode
   html-mode
   nxml-mode
   rjsx-mode
   web-mode)
  (rjsx-mode . +emmet-use-jsx-className)
  :custom
  (emmet-move-cursor-between-quotes t)
  :preface
  (defun +emmet-use-jsx-className ()
    "Set `emmet-expand-jsx-className?' as local variable."
    (setq-local emmet-expand-jsx-className? t)))
#+END_SRC

**** pug-mode
#+BEGIN_SRC emacs-lisp
(use-package pug-mode
  :mode "\\.\\(?:jade\\|pug\\)\\'")
#+END_SRC

**** slim-mode
#+BEGIN_SRC emacs-lisp
(use-package slim-mode
  :mode "\\.slim\\'")
#+END_SRC

**** web-mode
#+BEGIN_SRC emacs-lisp
(use-package web-mode
  :mode "\\.\\(phtml\\|php\\|[agj]sp\\|as[cp]x\\|erb\\|djhtml\\|html?\\|hbs\\|ejs\\|jade\\|swig\\|tmpl\\)\\'"
  :custom
  (web-mode-enable-html-entities-fontification t)
  ;; Highlight enclosing tags of the element under cursor
  (web-mode-enable-current-element-highlight t)
  ;; No extra indentation for blocks.
  (web-mode-script-padding 0)
  (web-mode-style-padding 0))
#+END_SRC

** yaml
#+BEGIN_SRC emacs-lisp
(use-package yaml-mode
  :mode "\\.\\(e?ya?\\|ra\\)ml\\'"
  :hook (yaml-mode . indent-guide-mode))
#+END_SRC

* Tools
** E-mail
*** Packages
**** bbdb
Store contacts.
#+BEGIN_SRC emacs-lisp
(use-package bbdb)
#+END_SRC

**** gmail2bbdb
Import contacts from Gmail vCard data.
#+BEGIN_SRC emacs-lisp
(use-package gmail2bbdb
  :config
  (setq gmail2bbdb-bbdb-file bbdb-file
        gmail2bbdb-exclude-people-without-name t))
#+END_SRC

** Focus
Dim out the surrounding text except the current focused paragraph or expression.
#+BEGIN_SRC emacs-lisp
(use-package focus)
#+END_SRC

** Indentation guides
#+BEGIN_SRC emacs-lisp
(use-package indent-guide
  :custom
  (indent-guide-char "\x2502"))
#+END_SRC

** Pomodoro
#+BEGIN_SRC emacs-lisp
(use-package redtick
  :general
  (:prefix
   init-launch-prefix
   "r" 'redtick))
#+END_SRC

** Session
Support for restoring previous session on Emacs restart. This adds a few tweaks that makes
it really useful.
- Support for persistent undo history via =buffer-undo-list=.
- Ignore saving of =gz= files as it seems not to properly load those.
- Only restore 5 files to begin with to avoid slow starts with huge sessions.
#+BEGIN_SRC emacs-lisp
(use-package desktop
  :demand t
  :custom
  (desktop-files-not-to-save "\\(\\`/[^/:]*:\\|(ftp)\\|\\.gz\\'\\)")
  (desktop-restore-eager 0)
  (desktop-save (daemonp))
  (desktop-load-locked-desktop (daemonp))
  :functions
  (desktop-buffer-info)
  :config
  (dolist (var '(buffer-undo-list ivy-views))
    (cl-pushnew var desktop-locals-to-save :test #'equal))
  (desktop-save-mode 1))
#+END_SRC

** Speed reading
#+BEGIN_SRC emacs-lisp
(use-package spray
  :custom
  (spray-height 500)
  (spray-margin-left 2)
  :config
  (setq spray-unsupported-minor-modes
        (append '(beacon-mode centered-window-mode visual-fill-column-mode)
                spray-unsupported-minor-modes))
  :general
  (:prefix
   init-launch-prefix
   "s" 'spray-mode))
#+END_SRC

** Spell checking
#+BEGIN_SRC emacs-lisp
(use-package flyspell
  :hook
  ((text-mode message-mode) . flyspell-mode)
  (prog-mode . flyspell-prog-mode)
  :general
  (:keymaps
   'flyspell-mode-map
   "C-," 'nil
   "C-." 'nil))
#+END_SRC

Automatically infer dictionary.
#+BEGIN_SRC emacs-lisp
(use-package auto-dictionary
  :commands
  (adict-mode))
#+END_SRC

** Undo
Navigate through undo history.
#+BEGIN_SRC emacs-lisp
(use-package undo-propose
  :general
  (:prefix
   init-launch-prefix
   "u" 'undo-propose))
#+END_SRC

* Private
#+BEGIN_SRC emacs-lisp
(require 'private nil t)
#+END_SRC

* The end
#+BEGIN_SRC emacs-lisp
(provide 'init)
;;; init.el ends here
#+END_SRC

* Tasks
** TODO Look into skewer packages
** TODO Look into modal editing with =objed=
** TODO Look into generic code execution via =isend-mode=
** TODO Add binding for org-noter
** TODO Group editing bindings under some logical prefix
** TODO Improve window keys
** TODO Improve find char keys
** TODO Extract history persistance code (persistory)
  - comint
  - ielm (via comint and savehist)
  - haskell-interactive (via savehist)
** TODO Enable auto-revert/save again?
** TODO Wrap lines by default?
  When writing code on a single line, to later let it be expanded by the formatter.
** TODO Only scale images that are larger than size X in org mode
** TODO Use =ielm= as REPL for org-mode
** TODO Use file-name as base for work-log date
** TODO Daily tasks
